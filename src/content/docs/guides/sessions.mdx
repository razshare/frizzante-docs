---
title: Sessions
---

import { FileTree } from '@astrojs/starlight/components'

Use `sessions.New()` to create a session then followup with `Start()` in order to start it.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

type State struct{                                       // Defines a struct which will hold the state 
    Name string                                          // of the session. This struct will later be
                                                         // initialized with a zero value.
}

func Welcome(connection *connections.Connection) {
    session := sessions.New(connection, State{}).Start() // Starts the session with zero state.
}
```

This will create and start the user's session.

:::note
The session is retrieved based on the user's `session-id` cookie.

If the user doesn't have a `session-id` cookie, `Start()` creates a 
new one instead and sends it to the user.
:::

:::danger
Since `Start()` may send a cookie, it is important to remember that
the order in which data is sent to the user matters.

Read more about [order of operations](../order-of-operations).
:::

## Save

Use `Save()` to save the session state.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

type State struct{                                       // Defines a struct which will hold the state 
    Name string                                          // of the session. This struct will later be
                                                         // initialized with a zero value.
}

func Welcome(connection *connections.Connection) {
    session := sessions.New(connection, State{}).Start() // Starts the session.
    defer session.Save()                                 // Saves the session's state.
                                                         // Since it's deferred, this will execute 
                                                         // when the handler terminates execution.

    session.State.Name = "World"                         // Modifies state.

                                                         // <== Deferred session.Save() executes.
}
```

## Load

Use `Load()` to load the session state.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

type State struct{                                        // Defines a struct which will hold the state 
    Name string                                           // of the session. This struct will later be
                                                          // initialized with a zero value.
}

func Welcome(connection *connections.Connection) {
    session := sessions.New(connection, State{}).Start()  // Starts the session.
    session.Load()                                        // Loads the session's state (not necessary, read below).
    connection.SendMessage("Hello " + session.State.Name) // Sends text.
}
```

:::tip
Session state is automatically loaded when invoking `Start()`.\
Generally speaking you wouldn't load the session state more than once per handler,
but there are some cases where it can be useful to do so, for example when handling
long running [server sent events](../server-sent-events) or [web socket](../web-sockets) connections.
:::

## Destroy

Use `Destroy()` to destroy a session.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

type State struct{                                       // Defines a struct which will hold the state 
    Name string                                          // of the session. This struct will later be
                                                         // initialized with a zero value.
}

func Welcome(connection *connections.Connection) {
    session := sessions.New(connection, State{}).Start() // Starts the session.
    session.Destroy()                                    // Destroys the session.
}
```


## Custom Archive

Sessions are managed through the servers's session archive which you can freely overwrite.

```go
//main.go
package main

import "github.com/razshare/frizzante/servers"

func main() {
    server := servers.New()                  // Creates a server.
    server.SessionArchive = &CustomArchive{} // Overwrite the default session archive.
                                             // The default session archive saves and loads
                                             // session from disk, you can overwrite this
                                             // in order to save and load sessions, for example,
                                             // using a database.
}
```

Where `CustomArchive` implements `archives.Archive`.

```go
type Archive interface {
    Get(domain string, key string) ([]byte, error)
    Set(domain string, key string, value []byte) error
    Has(domain string, key string) (bool, error)
    Remove(domain string, key string) error
    HasDomain(domain string) (bool, error)
    RemoveDomain(domain string) error
}
```

And subsequently, where `domain` is the user's session id and `key` is always set to `"session.json"`.

### Archive Details

Think of an archive as a repository of data separated in two layers; `domains` and `keys`.

An archive contains `domains` which contains `keys`.

<FileTree>
    - archive
        - domain-1
            - key-a
            - key-b
        - domain-2
            - key-x
            - key-y
</FileTree>

### Default Session Archive

The server's default session archive is backed by the file system,
more specifically, by a `.gen/sessions` directory.

<FileTree>
    - .gen
        - sessions
            - 0d0d0c2f-6bb9-405f-6a41-d4fe9acf3dd2
                - session.json
            - 8a6d8cfa-2fc7-4dbb-6be9-beb823318303
                - session.json
</FileTree>

```json
//.gen/sessions/0d0d0c2f-6bb9-405f-6a41-d4fe9acf3dd2/session.json
{
    "Name": "world"
}
```

Each `subdirectory` (**domain**) takes the id of a session and it contains the state in a `session.json` file (**key**), 
thus, there are as many subdirectories as there are sessions.

So given the interface from above, the following would a be description of what the default implementation does, at a high level.

```go
type Archive interface {
    Get(domain string, key string) ([]byte, error)     // Gets the contents of file .gen/sessions/{domain}/{key}.
    Set(domain string, key string, value []byte) error // Sets the contents of file .gen/sessions/{domain}/{key}.
    Has(domain string, key string) (bool, error)       // Checks if file .gen/sessions/{domain}/{key} exists.
    Remove(domain string, key string) error            // Removes file .gen/sessions/{domain}/{key}.
    HasDomain(domain string) (bool, error)             // Checks if directory .gen/sessions/{domain} exists.
    RemoveDomain(domain string) error                  // Removes directory .gen/sessions/{domain}.
}
```

:::note
Remember, `key` is always `"session.json"` in this context.
:::