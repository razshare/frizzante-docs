---
title: Sessions
---

import { FileTree } from '@astrojs/starlight/components'

Use `sessions.Start()` to start a session.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

type State struct{ // Defines session state,
    Name string    // which will be initialized
                   // with a zero value.
}

func Welcome(con *connections.Connection) {
    session := sessions.Start[State](con) // Starts session
                                          // with zero state.
}
```

This will retrieve the user's session or create a new one if none is found.

:::note
The session is retrieved based on the user's `session-id` cookie.

When session retrieval fails, `sessions.Start()` creates a 
new session instead and sends a new `session-id` cookie to the user.
:::

:::danger
Since `sessions.Start()` may send a cookie, it is important to remember that
the order in which data is sent to the user matters.

Read more about [order of operations](../order-of-operations).
:::

## Save

Use `Save()` to save the session state.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

// Defines session state.
type State struct{
    Name string
}

func Welcome(con *connections.Connection) {
    session := sessions.Start[State](con) // Starts session.
    defer sessions.Save(session)          // Saves state.
    session.State.Name = "World"          // Modifies state.
}
```

## Load

Use `Load()` to load the session state.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)
// Defines session state.
type State struct{
    Name string
}

func Welcome(con *connections.Connection) {
    session := sessions.Start[State](con) // Starts session.
    sessions.Load(session)                // Loads session state 
                                          // (not necessary, 
                                          // read below).
    name := session.State.Name
    con.SendMessage("Hello " + name)      // Sends text.
}
```

:::tip
Session state is automatically loaded when invoking `sessions.Start()`.\
Generally speaking you wouldn't load the session state more than once per handler,
but there are some cases where it can be useful to do so, for example when handling
long running [server sent events](../server-sent-events) or [web socket](../web-sockets) connections.
:::

## Destroy

Use `Destroy()` to destroy a session.

```go
//lib/handlers/welcome.go
package handlers

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/sessions"
)

// Defines session state.
type State struct{
    Name string
}

func Welcome(con *connections.Connection) {
    session := sessions.Start[State](con) // Starts session.
    sessions.Destroy(session)             // Destroys session.
}
```


## Custom Archive

Sessions are managed through the servers's session archive which you can freely overwrite.

```go
//main.go
package main

import "github.com/razshare/frizzante/servers"

func main() {
	server := servers.New()
	server.SessionArchive = &CustomArchive{}
}
```

Where `CustomArchive` implements `archives.Archive`.

```go
type Archive interface {
    Get(domain string, key string) ([]byte, error)
    Set(domain string, key string, value []byte) error
    Has(domain string, key string) (bool, error)
    Remove(domain string, key string) error
    HasDomain(domain string) (bool, error)
    RemoveDomain(domain string) error
}
```

### Archive Details

Think of an archive as a repository of data separated in two layers; `domains` and `keys`.

An archive contains `domains` which contains `keys`.

<FileTree>
    - archive
        - domain-1
            - key-a
            - key-b
        - domain-2
            - key-x
            - key-y
</FileTree>

### Default Session Archive

The default server session archive is backed by the file system,
more specifically, by a `.gen/sessions` directory.

<FileTree>
    - .gen
        - sessions
            - 0d0d0c2f-6bb9-405f-6a41-d4fe9acf3dd2
                - session.json
            - 8a6d8cfa-2fc7-4dbb-6be9-beb823318303
                - session.json
</FileTree>

```json
//.gen/sessions/0d0d0c2f-6bb9-405f-6a41-d4fe9acf3dd2/session.json
{
    "Name": "world"
}
```

Each `subdirectory` (**domain**) takes the id of a session and it contains the state in a `session.json` file (**key**), 
thus, there are as many subdirectories as there are sessions.