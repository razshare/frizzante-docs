---
title: Pages
---

import { FileTree } from '@astrojs/starlight/components';

Pages are defined through **controllers**.

A controller is just a directory grouping together a `page.go` file and `view.svelte` file.

By convention, all controllers must live under `lib/controllers`.

<FileTree>
    - makefile
    - main.go
    - lib
        - controllers
            - any
                - page.go
                - view.svelte
            - dashboard
                - page.go
                - view.svelte
            - welcome
                - page.go
                - view.svelte
</FileTree>

### Load Controllers

Controllers are not automatically loaded.

You can load the current package as a controller
into your server using `.LoadController()`.

```go
// lib/controllers/welcome.go

package welcome

import "main/lib/config"

func init() {
	config.Server.LoadController(nil)
}

```

This will load package `welcome` as a controller.

### Any

The `any` package has a special meaning.

It automatically takes over your root path `/`,
and because of that it is treated as a fallback controller,
meaning it will handle any request that doesn't match any controller.

For that reason, `any` is often paired with `.GiveWay()`,
which gives way to the file server before executing the controller itself.

:::note
This is useful for implementing SPAs, which often fallback to `/index.html`.
:::

```go
// lib/controllers/welcome.go

package welcome

import "main/lib/config"

func init() {
	config.Server.LoadController(nil).TryFileFirst()
}

```

### Views

When you invoke `.LoadController()`,
the server will implicitly use the nearby `view.svelte` as the rendering
template for the current controller.

### Base Function

Each controller can define a **base** function.

This function handles requests to the `GET` verb, and it generally
doesn't modify server state in any way, it just renders
data to the screen.

You users will most likely hit this function most of the time.

```go
// lib/controllers/welcome.go

func init() {
	config.Server.LoadController(func(controller *f.Controller) {
		controller.WithBase(base).
	})
}

func base(req *f.Request, res *f.Response) {
	res.SendView(f.NewView(f.RenderModeFull))
}
```

### Action Function

Each controller can define an **action** function.

This function handles requests to the `POST` verb. and
it usually modifies state in some way or redirects the user to another.

```go
// lib/controllers/welcome.go

func init() {
	config.Server.LoadController(func(controller *f.Controller) {
		controller.WithAction(base).
	})
}

var state = map[string]string{}

func action(req *f.Request, res *f.Response) {
	state["name"] = req.ReceiveQuery("name")
	res.SendNavigate("greeting")
}
```

### Data

You can inject data into views using `f.NewViewWithData()` instead of `f.NewView()`.

```go
// lib/controllers/welcome.go

func init() {
	config.Server.LoadController(func(controller *f.Controller) {
		controller.WithBase(base).
	})
}

type data struct {
	Name string `json:"name"`
}

func base(req *f.Request, res *f.Response) {
	res.SendView(f.NewViewWithData(f.RenderModeFull, data{
		Name: "world",
	}))
}
```

Then you can retrieve this data in your view using the [context](https://svelte.dev/docs/svelte/context) api.

```svelte
<script lang="ts">
    import {getContext} from "svelte";
    import type {ServerContext} from "$frizzante/types.ts";
    const server = getContext("server") as ServerContext<{
        name: string
    }>
</script>

<h1>Hello {server.data.name}!</h1>
```