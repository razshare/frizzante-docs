---
title: FAQ
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

## Why doesn't Frizzante have middleware?

Frizzante intentionally uses Guards instead of traditional middleware.

Traditional middleware has several limitations

- All middleware must be invoked for each request
- Some middleware may contain path-checking logic while others may not, which introduces ambiguity and more details to remember as a developer
- Managing middleware execution order across different routes is complex

### Guards

Instead of middleware that runs on every request, create guards that only run when specified through **tags**.

```go
const authentication tag.Tag = 0

srv.Guards = []guard.Guard{
    {                                                   // Adds guard.
        Name: "Authentication",                         // Sets guard name (useful for logs).
        Handler: func(c *client.Client, allow func()) { // Sets guard handler. If this handler returns without calling allow(), 
                                                        // it will block the request.
                                                        // Your guard logic here.
            allow()                                     // Allows the request through.
        },
        Tags: []tag.Tag{authentication},                // Tags the guard. Use this tag on any route in order to apply it.
    },
}

srv.Routes = []route.Route{
    {                                                   // Adds route.
        Pattern: "GET /dashboard",                      // Sets route pattern.
        Handler: dashboardHandler,                      // Sets route handler.
        Tags: []tag.Tag{authentication},                // Tags the route. This will apply the "Authentication" guard.
    },
    {                                                   // Adds route.
        Pattern: "GET /public",                         // Sets route pattern.
        Handler: publicHandler,                         // Sets route handler.
                                                        // No tags - this route is not protected by any guard.
    },
}
```

### Benefits of Guards

- **Explicit** - you can see exactly which routes use which guards by looking at their tags
- **Efficient** - guards only execute when their tags match - no wasted computation
- **Composable** - easy to manage execution order per route

For more details see the [guard page](../guards).

### Middleware Implementation

If you really want middleware-like behavior, you can easily implement it in your own project.

```go
//lib/middleware/types.go
package middleware

import "github.com/razshare/frizzante/client"

type Hook func(c *client.Client, next func()) // Defines a hook function type which will be used by the middleware.

type Middleware struct {                      // Defines a structure, which holds multiple hooks.
    Hooks []Hook                              // Defines the actual hooks slice.
}
```

```go
//lib/middleware/apply.go
package middleware

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/route"
)

func Apply(mid *Middleware, routes []route.Route) {
    for _, _route := range routes {                 // For each route...
        handler := _route.Handler                   // ...saves the route handler for later use.
        _route.Handler = func(c *client.Client) {   // Assigns a new wrapper route handler.
            var quit = true                         // Creates flag used to interrupt the chain.
            for _, hook := range mid.Hooks {        // For each hook...
                quit = true                         // ...prepares to quit...
                hook(c, func() { quit = false })    // ...invokes the hook...
                if quit {                           // Checks if route should quit.
                    return                          // Quits.
                }
            }
            handler(c)                              // Invokes the actual route handler.
        }
    }
}
```
:::note
Your implementation may vary.\
This implementation doesn't directly invoke the next hook, instead it sets a flag.\
This should keep you stack size smaller and thus more readable.
:::

### Middleware Usage

```go
//main.go
package main

import (
    "embed"
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/route"
    "github.com/razshare/frizzante/server"
    "github.com/razshare/frizzante/svelte/ssr"
    "main/lib/middleware"
    "main/lib/routes/handlers/fallback"
    "main/lib/routes/handlers/todos"
    "main/lib/routes/handlers/welcome"
    "os"
)

//go:embed app/dist
var efs embed.FS
var srv = server.New()
var dev = os.Getenv("DEV") == "1"
var render = ssr.New(ssr.Config{Efs: efs, Disk: dev})


var mid = &middleware.Middleware{             // Creates middleware.
    Hooks: []middleware.Hook{                 // Creates hooks.
        func(c *client.Client, next func()) { // Handle hook.
                                              // Middleware logic goes here.
        },
    },
}

func main() {
    defer server.Start(srv)
    defer middleware.Apply(mid, srv.Routes)   // Applies middleware hooks to given routes.
                                              // Remember that deferred functions are executed in reverse,
                                              // so this line will execute before the server starts.
    srv.Efs = efs
    srv.Render = render
    srv.Routes = []route.Route{
        {Pattern: "GET /", Handler: fallback.View},
        {Pattern: "GET /welcome", Handler: welcome.View},
        {Pattern: "GET /todos", Handler: todos.View},
        {Pattern: "GET /check", Handler: todos.Check},
        {Pattern: "GET /uncheck", Handler: todos.Uncheck},
        {Pattern: "GET /add", Handler: todos.Add},
        {Pattern: "GET /remove", Handler: todos.Remove},
    }
}
```
