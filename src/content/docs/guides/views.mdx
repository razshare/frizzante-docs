---
title: Views
---

import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components'

Views are `.svelte` files located under `lib/components/views`.

<FileTree>
    - main.go
    - lib
        - components
            - views
                - Hello.svelte
                - Login.svelte
                - Profile.svelte
                - ...
</FileTree>

## Render Files

Before sending views to the user, you'll need to **generate**
some **glue code**.

```sh
make update generate
```

The output is generated in `.generated/`.

<FileTree>
    - main.go
    - .generated
        - client.svelte
        - client.ts
        - server.svelte
        - server.ts
        - view.svelte
</FileTree>

These are glue files that bootstrap your **view** components
and make sure to render them at the correct time on both 
the server and the client.

There is no magic going on here, all these files do is simply switch between different views 
based on the current view **name**.

<Tabs>
    <TabItem icon='seti:svelte' label='.generated/client.svelte'>
    ```svelte
    <script lang="ts">
        import ViewComponent from './view.svelte'
        import {setContext} from "svelte"

        let {name, data, error, renderMode} = $props()
        const view = $state({name, data, error, renderMode})
        setContext("view", view)
    </script>
    {#if 'Todos' === view.name}
        <ViewComponent from={import('./../../lib/components/views/Todos.svelte')}/>
    {:else if 'Welcome' === view.name}
        <ViewComponent from={import('./../../lib/components/views/Welcome.svelte')}/>
    {/if}
    ```
    </TabItem>
    <TabItem icon='seti:typescript' label='.generated/client.ts'>
    ```ts
    import { hydrate } from "svelte";
    import RenderClient from "./client.svelte";

    target().innerHTML = "";
    hydrate(RenderClient, { target: target(), props: props() });
    ```
    :::note
    Functions `target()` and `props()` are injected dynamically into the Html document.
    :::
    </TabItem>
</Tabs>

<Tabs>
    <TabItem icon='seti:svelte' label='.generated/server.svelte'>
    ```svelte
    <script lang="ts">
        import TODOS from './../../lib/components/views/Todos.svelte'
        import WELCOME from './../../lib/components/views/Welcome.svelte'
        import {setContext} from "svelte"

        let {name, data, error, renderMode} = $props()
        const view = $state({name, data, error, renderMode})
        setContext("view", view)
    </script>

    {#if 'Todos' === view.name}
        <TODOS/>
    {:else if 'Welcome' === view.name}
        <WELCOME/>
    {/if}
    ```
    </TabItem>
    <TabItem icon='seti:typescript' label='.generated/server.ts'>
    ```ts
    import { render as _render } from "svelte/server";
    import RenderServer from "./server.svelte";
    export async function render(props:unknown) {
        return _render(RenderServer, { props });
    }
    ```
    </TabItem>
</Tabs>




It's simple and readable, there's no need for an advanced programmatic router.

---

:::note
You'll need to generate these files once again 
when you add a new view to your application.
:::

## Send Views

You can to send views with `res.SendView()`.

```go
//lib/routes/handler.go
package lib

import frz "github.com/razshare/frizzante"

func GetHello(req *frz.Request, res *frz.Response) {
    // Sends file "lib/components/views/Hello.svelte"
    res.SendView(frz.View{Name: "Hello"}) 
}
```

## Data

Optionally, you can send data along with the views by adding a `Data` property to your `View`.

```go
//lib/routes/handler.go
package lib

import frz "github.com/razshare/frizzante"

func GetHello(req *frz.Request, res *frz.Response) {
    res.SendView(frz.View{ 
		Name: "Hello",
		Data: map[string]string{
			"name": "world",
		}
	}) 
}
```

Then use [getContext("server")](https://svelte.dev/docs/svelte/context) to retrieve your data.

```svelte
<script lang="ts">
    import type { ServerContext } from "$frizzante/types.ts"
    const server = getContext("server") as ServerContext<{ name: string }>
</script>

<h1>Hello {server.data.name}</h1>
```

Since this data is provided [using the context api](https://svelte.dev/docs/svelte/context), it can be accessed not only by the root component (your view), but also by any other component.

```svelte
//lib/components/views/Example.svelte
<script lang="ts">
	import SayHello from "$lib/components/SayHello.svelte"
</script>

<SayHello/>
```

```svelte
//lib/components/SayHello.svelte
<script lang="ts">
	import type { SvelteContext } from "$frizzante/types.ts"
	const server = getContext("server") as ServerContext<{ name: string }>
</script>

<h1>Hello {server.data.name}</h1>
```

As you can see, in this example, view `lib/components/views/Example.svelte`
doesn't concern itself with passing the name down to `<SayHello/>`,
because `<SayHello/>` itself can get access to the data directly 
by simply invoking `getContext("server")`.


## Render Modes

When sending views, you can choose how to render them with the `RenderMode` 
property.

<Tabs>
    <TabItem label='Server'>
    
        ```go
        //lib/routes/handler.go
        package lib

        import frz "github.com/razshare/frizzante"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeServer, // Renders on server.
            })
        }
        ```
        :::tip
        While using `RenderModeServer` your application won't serve a JavaScript bundle,
        but you can still use the `<svelte:head>` special
        tag in order to load scripts dynamically.
        ```svelte
        <svelte:head>
            <script type="text/javascript" src="https://some.cdn/some.js" />
        </svelte:head>
        ```
        :::
    </TabItem>
    <TabItem label='Client'>
        ```go
        //lib/routes/handler.go
        package lib

        import frz "github.com/razshare/frizzante"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeClient, // Renders on client.
            })
        }
        ```
    </TabItem>
    <TabItem label='Full'>
        ```go
        //lib/routes/handler.go
        package lib

        import frz "github.com/razshare/frizzante"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeFull,   // Renders on client and server.
            })
        }
        ```
    </TabItem>
</Tabs>