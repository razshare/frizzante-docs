---
title: Views
---

import { FileTree } from '@astrojs/starlight/components'

Views are **svelte components** exported by 
`app/exports/server.ts` and/or `app/exports/client.ts`.

<FileTree>
    - main.go
    - app
        - exports
            - client.ts
            - server.ts
            - ...
</FileTree>

### Server Exports

Views that are meant to be rendered on the server should be exported by `app/exports/server.ts`.
```ts
//app/exports/server.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

// Defines that components "Welcome" and "Profile"
// can be rendered on the server when 
// sent with `connections.SendView()`.
export const views = {
    "Welcome": Welcome,
    "Profile": Profile,
}
```

### Client Exports

Views that are meant to be rendered on the client should be exported by `app/exports/client.ts`.
```ts
//app/exports/client.ts

// Defines that components "Welcome" and "Profile"
// can be bundled and rendered on the client when
// sent with `connections.SendView()`.
export const views = {
    "Welcome": import('$lib/views/Welcome.svelte'),
    "Profile": import('$lib/views/Profile.svelte'),
}
```

These views are being imported asynchronously in order to split them 
in different bundles, however you can simply create fake promises
in order to bundle them all together and eliminate network latency
when transitioning between views.

```ts
//app/exports/client.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {
    "Welcome": Promise.resolve(Welcome),
    "Profile": Promise.resolve(Profile),
}
```

## Send Views

Use `connections.SendView()` to send a view from a route handler.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Sends view "Welcome".
    connections.SendView(con, views.View{Name: "Welcome"}) 
}
```

The **Name** of the view will be used to lookup the view component exported by **server.ts** and/or **client.ts**.

## Default View

There is no way to specify a "**default view**".

However, you can use `connections.SendFileOrElse()` in order to send a file or run custom logic if it doesn't exist.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Attempts to send file requested 
    // by the user, or else...
    connections.SendFileOrElse(con, func () {
        // ... sends view "Welcome".
        connections.SendView(con, views.View{Name: "Welcome"})
    })
}
```

Usually you would map this handler to the default `GET /` pattern, which automatically captures
all unmatched requests.

```go
package main

import (
    "embed"
    "github.com/razshare/frizzante/web"
)

//go:embed app/dist
var efs embed.FS
var server = servers.New()
var route = routes.Route{
    Pattern: "GET /",
    Handler: handlers.Welcome,
}

func main() {
    server.Efs = efs
    servers.AddRoute(server, route)
    servers.Start(server)
}
```

## Data

Optionally, you can send data along with the views by adding a `Data` property to your `View`.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Sends view "Welcome".
    connections.SendView(con, views.View{ 
        Name: "Welcome",
        Data: map[string]string{
            // Adds property "name" 
            // with value "world".
            "name": "world",
        },
    }) 
}
```

These properties are passed down to your view component.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    type Props = { name: string }
    let {name}:Props = $props()
</script>

<h1>Hello {name}</h1>
```

You can also use [getContext("view")](https://svelte.dev/docs/svelte/context) to retrieve your data.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    import type { View } from "$frizzante/types.ts"
    const view = getContext("view") as View<{ name: string }>
</script>

<h1>Hello {view.data.name}</h1>
```

## Render Modes

You can choose how to render views with the `RenderMode` property.

### RenderModeFull

Using `RenderModeFull`, the view is rendered on both the server and the client.<br/>
This is the **default** mode.
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Sends view "Welcome".
    connections.SendView(con, views.View{
        Name: "Welcome",
        // Renders view on server and client.
        RenderMode: views.RenderModeFull,
    })
}
```

### RenderModeServer

Using `RenderModeServer`, the view is rendered only on the server.<br/>
You'll have to deal away with apis such as [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API); 
your new best friend is [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form).
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Sends view "Welcome".
    connections.SendView(con, views.View{
        Name: "Welcome",
        // Renders view on server.
        RenderMode: views.RenderModeServer,
    })
}
```
:::tip
While using `RenderModeServer` the view won't serve a JavaScript bundle,
but you can still use the `<svelte:head>` special
tag in order to load scripts dynamically.
```svelte
<svelte:head>
    <script type="text/javascript" src="https://some.cdn/file.js" />
</svelte:head>
```
:::


### RenderModeClient

Using `RenderModeClient`, the view is rendered only on the client by loading a JavaScript bundle asynchronously.
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    // Sends view "Welcome".
    connections.SendView(con, views.View{
        Name: "Welcome",
        // Renders view on client.
        RenderMode: views.RenderModeClient,
    })
}
```

:::tip
You can combine any of these render modes with adaptive hyperlinks and forms.
Read more about [web standards](../web-standards).
:::
