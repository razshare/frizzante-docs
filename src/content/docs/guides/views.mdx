---
title: Views
---

import { FileTree, Tabs, TabItem } from '@astrojs/starlight/components'

Views are `.svelte` files located under `lib/components/views`.

<FileTree>
    - main.go
    - lib
        - components
            - views
                - Hello.svelte
                - Login.svelte
                - Profile.svelte
                - ...
</FileTree>

## Render Files

Before sending views to the user, you'll need to **generate**
some **glue code**.

```sh
make update generate
```

The output is generated in `.generated/`.

<FileTree>
    - main.go
    - .generated
        - client.svelte
        - client.ts
        - server.svelte
        - server.ts
        - view.svelte
</FileTree>

These are glue files that bootstrap your **view** components
and make sure to render them at the correct time on both 
the server and the client.

There is no magic going on here, all these files do is simply switch between different views 
based on the current view **name**.

<Tabs>
    <TabItem icon='seti:svelte' label='.generated/client.svelte'>
    ```svelte
    <script lang="ts">
        import ViewComponent from './view.svelte'
        import {setContext} from "svelte"

        let {name, data, error, renderMode} = $props()
        const view = $state({name, data, error, renderMode})
        setContext("view", view)
    </script>
    {#if 'Todos' === view.name}
        <ViewComponent from={import('./../../lib/components/views/Todos.svelte')}/>
    {:else if 'Welcome' === view.name}
        <ViewComponent from={import('./../../lib/components/views/Welcome.svelte')}/>
    {/if}
    ```
    </TabItem>
    <TabItem icon='seti:typescript' label='.generated/client.ts'>
    ```ts
    import { hydrate } from "svelte";
    import RenderClient from "./client.svelte";

    target().innerHTML = "";
    hydrate(RenderClient, { target: target(), props: props() });
    ```
    :::note
    Functions `target()` and `props()` are injected dynamically into the Html document.
    :::
    </TabItem>
</Tabs>

<Tabs>
    <TabItem icon='seti:svelte' label='.generated/server.svelte'>
    ```svelte
    <script lang="ts">
        import TODOS from './../../lib/components/views/Todos.svelte'
        import WELCOME from './../../lib/components/views/Welcome.svelte'
        import {setContext} from "svelte"

        let {name, data, error, renderMode} = $props()
        const view = $state({name, data, error, renderMode})
        setContext("view", view)
    </script>

    {#if 'Todos' === view.name}
        <TODOS/>
    {:else if 'Welcome' === view.name}
        <WELCOME/>
    {/if}
    ```
    </TabItem>
    <TabItem icon='seti:typescript' label='.generated/server.ts'>
    ```ts
    import { render as _render } from "svelte/server";
    import RenderServer from "./server.svelte";
    export async function render(props:unknown) {
        return _render(RenderServer, { props });
    }
    ```
    </TabItem>
</Tabs>




It's simple and readable, there's no need for an advanced programmatic router.

---

:::note
You'll need to generate these files once again 
when you add or remove views.
:::

## Send Views

You can to send views with `res.SendView()`.

```go
//lib/routes/handler.go
package lib

import "github.com/razshare/frizzante/frz"

func GetHello(req *frz.Request, res *frz.Response) {
    // Sends file "lib/components/views/Hello.svelte"
    res.SendView(frz.View{Name: "Hello"}) 
}
```

## Data

Optionally, you can send data along with the views by adding a `Data` property to your `View`.

```go
//lib/routes/handler.go
package lib

import "github.com/razshare/frizzante/frz"

func GetHello(req *frz.Request, res *frz.Response) {
    res.SendView(frz.View{ 
		Name: "Hello",
		Data: map[string]string{
			"name": "world",
		}
	}) 
}
```

Then use [getContext("server")](https://svelte.dev/docs/svelte/context) to retrieve your data.

```svelte
//lib/components/views/Hello.svelte
<script lang="ts">
    import type { ServerContext } from "$frizzante/types.ts"
    const server = getContext("server") as ServerContext<{ name: string }>
</script>

<h1>Hello {server.data.name}</h1>
```

## Render Modes

You can choose how to render views with the `RenderMode` property.

<Tabs>
    <TabItem label='Server'>
    
        ```go
        //lib/routes/handler.go
        package lib

        import "github.com/razshare/frizzante/frz"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeServer, // Renders on server.
            })
        }
        ```
        :::tip
        While using `RenderModeServer` your application won't serve a JavaScript bundle,
        but you can still use the `<svelte:head>` special
        tag in order to load scripts dynamically.
        ```svelte
        <svelte:head>
            <script type="text/javascript" src="https://some.cdn/some.js" />
        </svelte:head>
        ```
        :::
    </TabItem>
    <TabItem label='Client'>
        ```go
        //lib/routes/handler.go
        package lib

        import "github.com/razshare/frizzante/frz"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeClient, // Renders on client.
            })
        }
        ```
    </TabItem>
    <TabItem label='Full'>
        ```go
        //lib/routes/handler.go
        package lib

        import "github.com/razshare/frizzante/frz"

        func GetHello(req *frz.Request, res *frz.Response) {
            res.SendView(frz.View{
                Name: "Hello",
                RenderMode: frz.RenderModeFull,   // Renders on client and server.
            })
        }
        ```
    </TabItem>
</Tabs>