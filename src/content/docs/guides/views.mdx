---
title: Views
---

import { FileTree } from '@astrojs/starlight/components'

## What are views?

Views are **svelte components** exported by 
`app/exports.server.ts` and/or `app/exports.client.ts`.

<FileTree>
    - app
        - exports.client.ts
        - exports.server.ts
        - ...
</FileTree>

## Server Exports

Views that are meant to be rendered on the server should be exported by `app/exports.server.ts`.
```ts
//app/exports.server.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {
    "Welcome": Welcome,
    "Profile": Profile,
}
```

## Client Exports

Views that are meant to be rendered on the client should be exported by `app/exports.client.ts`.
```ts
//app/exports.client.ts
export const views = {
    "Welcome": import('$lib/views/Welcome.svelte'),
    "Profile": import('$lib/views/Profile.svelte'),
}
```
:::note
These views are being imported asynchronously in order to split them 
in different bundles, however you can simply create fake promises
in order to bundle them all together and eliminate network latency
when transitioning between views.

```ts
//app/exports.client.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {
    "Welcome": Promise.resolve(Welcome),
    "Profile": Promise.resolve(Profile),
}
```
:::

:::note
Keys in `app/exports.server.ts` and `app/exports.client.ts` are not mutually exclusive.\
You can render the same component on both the server and the client at the same time.\
See [Render Modes below](#render-modes).
:::

## Send Views

Use `send.View()` to send a view.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.View(client, view.View{Name: "Welcome"}) // Sends view "Welcome".
}
```

The **Name** of the view will be used to lookup the view component exported by **app/exports.server.ts** and/or **app/exports.client.ts**.

## Default View

There is no way to specify a "**default view**".

However, you can use `send.FileOrElse()` in order to send the requested file or run custom logic if it doesn't exist.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
	"os"

    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.FileOrElse(client, func() { welcome.View(client) })
}
```

Usually you would map this handler to the default `GET /` pattern, which automatically captures
all unmatched requests.

```go
package main

import (
    "embed"
    "main/lib/core/client"
    "main/lib/core/server"
)

//go:embed app/dist
var efs embed.FS
var srv = server.New()                           // Creates server.

func main() {
    defer server.Start(srv)                      // Starts server.
	srv.Efs = efs                                // Sets embedded file system.
    srv.Routes = append(srv.Routes, route.Route{ // Adds route to the server.
        Pattern: "GET /",
        Handler: welcome.View,
    })
}
```

## View Properties

Optionally, you can specify properties for your `View` with the `Props` field.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.View(client, view.View{ // Sends view.
       Name: "Welcome",          // Sets view name.
       Props: map[string]string{ // Sets view props, which will be injected into the svelte component.
          "name": "world",       // Adds property "name" with value "world".
       },
    }) 
}
```

These properties are passed down to your view component.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    type Props = { name: string }
    let {name}:Props = $props() // Retrieves view props.
</script>

<h1>Hello {name}</h1>
```

:::note
View properties are initialized with [$state()](https://svelte.dev/docs/svelte/$state) and thus are reactive by default.
:::

:::tip
You can also use [getContext("view")](https://svelte.dev/docs/svelte/context) to retrieve your properties.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    import type { View } from "$lib/scripts/core/types.ts"
    const view = getContext("view") as View<{ name: string }> // Retrieves the same server props, 
                                                              // but can be used anywhere in the project
                                                              // regardless of the component hierarchy.
</script>

<h1>Hello {view.props.name}</h1>
```
:::note
`view` is initialized with [$state()](https://svelte.dev/docs/svelte/$state) and thus is reactive.
:::

:::tip
Instead of manually defining TypeScript/JSDoc type definitions, use the cli to automatically generate them.\
Read more about [type definitions](../type-definitions).
:::

## Render Modes

You can choose how to render views by setting the `RenderMode` field in your `View`.

### RenderModeFull

Using `RenderModeFull`, the view is rendered on both the server and the client.<br/>
This is the **default** mode.
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.View(client, view.View{        // Sends view.
       Name: "Welcome",                 // Sets view name.
       RenderMode: view.RenderModeFull, // Renders view on server and client.
    })
}
```

### RenderModeServer

Using `RenderModeServer`, the view is rendered only on the server.<br/>
You'll have to deal away with apis such as [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API); 
your new best friend is [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form).
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.View(client, view.View{          // Sends view.
       Name: "Welcome",                   // Sets view name.
       RenderMode: view.RenderModeServer, // Renders view only on server.
    })
}
```

:::tip
While using `RenderModeServer` the view won't serve a JavaScript bundle,
but you can still use the `<svelte:head>` special
tag in order to load scripts dynamically.
```svelte
<svelte:head>
    <script type="text/javascript" src="https://some.cdn/file.js" />
</svelte:head>
```
:::

### RenderModeClient

Using `RenderModeClient`, the view is rendered only on the client by loading a JavaScript bundle asynchronously.
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "main/lib/core/client"
    "main/lib/core/send"
    "main/lib/core/view"
)

func View(client *client.Client) {
    send.View(client, view.View{          // Sends view.
       Name: "Welcome",                   // Sets view name.
       RenderMode: view.RenderModeClient, // Renders view only on client.
    })
}
```

:::tip
You can combine any of these render modes with adaptive hyperlinks and forms.\
Read more about [web standards](../web-standards).
:::

:::tip
When using `RenderModeFull` or `RenderModeServer`, You can configure how many JavaScript runtimes are executed in parallel by setting the `FRIZZANTE_RENDER_LIMIT` environment variable.
```sh
//.gen/bin
FRIZZANTE_RENDER_LIMIT=3 ./app
```

:::caution
Settings this limit too high could lead to large memory usage by your JavaScript runtimes.\
For most use cases a limit of 1 runtime (the default) is more than enough, after all, the Svelte compiler
is simply concatenating strings together when rendering pages on the server.\
Modify this field based on actual performance measurements.
:::

## Disabling the server-side JavaScript runtime.

You can add the `no_js_runtime` tag to your build process to completely disable the server-side JavaScript runtime.

```sh
frizzante --build --tags="no_js_runtime"
```

This will drop the server-side JavaScript runtime, reducing the minimum size of the final binary from
25MB to 10MB.