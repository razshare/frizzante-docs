---
title: Views
---

import { FileTree } from '@astrojs/starlight/components'

Before rendering views you need to assign a **rendering function** to your server.\
This rendering function is used to render views when invoking `send.View()`.

You can choose between two types of rendering functions: `csr` and `ssr`.

### Csr Function

The csr function simply reads the contents of your `index.html`, injects the view properties into the document and returns the result.

You can create a csr function using `csr.New()`.

```go
//main.go
package main

import (
	"embed"
	"github.com/razshare/frizzante/server"
	"github.com/razshare/frizzante/svelte/csr"
	"os"
)

//go:embed app/dist
var efs embed.FS
var srv = server.New()
var dev = os.Getenv("DEV") == "1"
var render = csr.New(csr.Config{Efs: efs, Disk: dev})

func main() {
	defer server.Start(srv)
	srv.Efs = efs
	srv.Render = render
}
```

:::tip
Csr functions default to reading from the given embedded file system (`Efs`).\
You can force the function to read from the disk instead by setting `Disk: true`.

This can be helpful while developing in order to get instant feedback from Vite.
:::


### Ssr Function

The ssr function uses a JavaScript engine in order to render svelte components on the fly and returns the result.

You can create an ssr function using `ssr.New()`.

```go
//main.go
package main

import (
	"embed"
	"github.com/razshare/frizzante/server"
	"github.com/razshare/frizzante/svelte/ssr"
	"os"
)

//go:embed app/dist
var efs embed.FS
var srv = server.New()
var dev = os.Getenv("DEV") == "1"
var render = ssr.New(ssr.Config{Efs: efs, Disk: dev})

func main() {
	defer server.Start(srv)
	srv.Efs = efs
	srv.Render = render
}
```

:::tip
Ssr functions default to reading from the given embedded file system (`Efs`).\
You can force the function to read from the disk instead by setting `Disk: true`.

This can be helpful while developing in order to get instant feedback from Vite.
:::

## What are views?

Views are **svelte components** exported by 
`app/exports/server.ts` and/or `app/exports/client.ts`.

<FileTree>
    - main.go
    - app
       - exports
          - client.ts
          - server.ts
          - ...
</FileTree>

## Server Exports

Views that are meant to be rendered on the server should be exported by `app/exports/server.ts`.
```ts
//app/exports/server.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {  // Defines that components "Welcome" and "Profile"
                        // can be rendered on the server when sent with send.View().

    "Welcome": Welcome, // When send.View(view.View{Name:"Welcome"}) is invoked, 
                        // the component will render on the server.

    "Profile": Profile, // When send.View(view.View{Name:"Profile"}) is invoked, 
                        // the component will render on the server.
}
```

## Client Exports

Views that are meant to be rendered on the client should be exported by `app/exports/client.ts`.
```ts
//app/exports/client.ts
export const views = { // Defines that components "Welcome" and "Profile"
                       // can be bundled and rendered on the client when
                       // sent with send.View().

    "Welcome": import('$lib/views/Welcome.svelte'), // When send.View(view.View{Name:"Welcome"}) is invoked, 
                                                    // the component will render on the client.

    "Profile": import('$lib/views/Profile.svelte'), // When send.View(view.View{Name:"Profile"}) is invoked, 
                                                    // the component will render on the client.
}
```

These views are being imported asynchronously in order to split them 
in different bundles, however you can simply create fake promises
in order to bundle them all together and eliminate network latency
when transitioning between view.

```ts
//app/exports/client.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {
    "Welcome": Promise.resolve(Welcome),
    "Profile": Promise.resolve(Profile),
}
```

:::note
Keys in `app/exports/server.ts` and `app/exports/client.ts` are not mutually exclusive.\
You can render the same component on both the server and the client at the same time.\
See [Render Modes below](#render-modes).
:::

## Send Views

Use `send.View()` to send a view.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.View(c, view.View{Name: "Welcome"}) // Sends view "Welcome".
}
```

The **Name** of the view will be used to lookup the view component exported by **app/exports/server.ts** and/or **app/exports/client.ts**.

:::caution
If the view **Name** is not present in neither `app/exports/server.ts` or `app/exports/client.ts`, `send.View()` will fail.
:::

## Default View

There is no way to specify a "**default view**".

However, you can use `send.FileOrElse()` in order to send a file or run custom logic if it doesn't exist.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.FileOrElse(c, func () {                // Attempts to send requested file, or else...
       send.View(c, view.View{Name: "Welcome"}) // ...sends view "Welcome".
    })
}
```

Usually you would map this handler to the default `GET /` pattern, which automatically captures
all unmatched requests.

```go
package main

import (
    "embed"
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/svelte/container/server"
)

//go:embed app/dist
var efs embed.FS
var srv = server.Default(efs)               // Creates server config.
var route = route.Route{                    // Creates route.
    Pattern: "GET /",                       // Sets route pattern.
    Handler: welcome.View,                  // Sets route handler.
}

func main() {
    defer server.Start(srv)                // Starts the server.
    srv.Routes = append(srv.Routes, route) // Adds the route to the server.
}
```

## Props

Optionally, you can send Props along with the views by adding a `Props` field to your `View`.

```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.View(c, view.View{      // Sends view.
       Name: "Welcome",          // Sets view name.
       Props: map[string]string{ // Sets view props, which will be injected into the svelte component.
          "name": "world",       // Adds property "name" with value "world".
       },
    }) 
}
```

These properties are passed down to your view component.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    type Props = { name: string }
    let {name}:Props = $props() // Retrieves server props.
</script>

<h1>Hello {name}</h1>
```

You can also use [getContext("view")](https://svelte.dev/docs/svelte/context) to retrieve your props.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    import type { View } from "$frizzante/types.ts"
    const view = getContext("view") as View<{ name: string }> // Retrieves the same server props, 
                                                              // but can be used anywhere in the project
                                                              // regardless of the component hierarchy.
</script>

<h1>Hello {view.props.name}</h1>
```

## Render Modes

You can choose how to render views with the `Render` property.

:::caution
Some modes are only available while using a specific rendering function, for example `RenderFull` and `RenderServer` 
are only supported by the [ssr function](#ssr-function).
:::

### RenderFull

Using `RenderFull`, the view is rendered on both the server and the client.<br/>
This is the **default** mode.
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.View(c, view.View{     // Sends view.
       Name: "Welcome",         // Sets view name.
       Render: view.RenderFull, // Renders view on server and client.
    })
}
```

:::note
Requires an [ssr function](#ssr-function).
:::

### RenderServer

Using `RenderServer`, the view is rendered only on the server.<br/>
You'll have to deal away with apis such as [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API); 
your new best friend is [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form).
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.View(c, view.View{       // Sends view.
       Name: "Welcome",           // Sets view name.
       Render: view.RenderServer, // Renders view only on server.
    })
}
```

:::note
Requires an [ssr function](#ssr-function).
:::

:::tip
While using `RenderServer` the view won't serve a JavaScript bundle,
but you can still use the `<svelte:head>` special
tag in order to load scripts dynamically.
```svelte
<svelte:head>
    <script type="text/javascript" src="https://some.cdn/file.js" />
</svelte:head>
```
:::


### RenderClient

Using `RenderClient`, the view is rendered only on the client by loading a JavaScript bundle asynchronously.
```go
//lib/routes/handlers/welcome/view.go
package lib

import (
    "github.com/razshare/frizzante/client"
    "github.com/razshare/frizzante/send"
    "github.com/razshare/frizzante/view"
)

func View(c *client.Client) {
    send.View(c, view.View{       // Sends view.
       Name: "Welcome",           // Sets view name.
       Render: view.RenderClient, // Renders view only on client.
    })
}
```

:::note
Requires a [csr](#csr-function) or [ssr](#ssr-function) function.
:::

:::tip
You can combine any of these render modes with adaptive hyperlinks and forms.
Read more about [web standards](../web-standards).
:::

## Why use Csr Function at all?

Since the [ssr function](#ssr-function) supports all rendering modes, you might ask yourself why not just use it at all times?

The main reason you would want to switch to a [csr function](#csr-function) is because of the binary size.\
While it's true that you can simply choose to only use `RenderClient` when using an [ssr function](#ssr-function), your binary will still bundle the required JavaScript engine, even if you're not making use of it.

But using a [csr function](#csr-function), the JavaScript engines gets dropped completely from your binary, which lowers the minimum binary size from 24MB to 10MB in size.