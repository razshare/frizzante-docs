---
title: Views
---

import { FileTree } from '@astrojs/starlight/components'

Views are **svelte components** exported by 
`app/exports/server.ts` and/or `app/exports/client.ts`.

<FileTree>
    - main.go
    - app
        - exports
            - client.ts
            - server.ts
            - ...
</FileTree>

### Server Exports

Views that are meant to be rendered on the server should be exported by `app/exports/server.ts`.
```ts
//app/exports/server.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {  // Defines that components "Welcome" and "Profile"
                        // can be rendered on the server when sent with SendView().

    "Welcome": Welcome, // When SendView(views:View{Name:"Welcome"}) is invoked, 
                        // the component will render on the server.

    "Profile": Profile, // When SendView(views:View{Name:"Profile"}) is invoked, 
                        // the component will render on the server.
}
```

### Client Exports

Views that are meant to be rendered on the client should be exported by `app/exports/client.ts`.
```ts
//app/exports/client.ts
export const views = { // Defines that components "Welcome" and "Profile"
                       // can be bundled and rendered on the client when
                       // sent with SendView().

    "Welcome": import('$lib/views/Welcome.svelte'), // When SendView(views:View{Name:"Welcome"}) is invoked, 
                                                    // the component will render on the client.

    "Profile": import('$lib/views/Profile.svelte'), // When SendView(views:View{Name:"Profile"}) is invoked, 
                                                    // the component will render on the client.
}
```

These views are being imported asynchronously in order to split them 
in different bundles, however you can simply create fake promises
in order to bundle them all together and eliminate network latency
when transitioning between views.

```ts
//app/exports/client.ts
import Welcome from '$lib/views/Welcome.svelte'
import Profile from '$lib/views/Profile.svelte'

export const views = {
    "Welcome": Promise.resolve(Welcome),
    "Profile": Promise.resolve(Profile),
}
```

:::note
Keys in `app/exports/server.ts` and `app/exports/client.ts` are not mutually exclusive.\
You can render the same component on both the server and the client at the same time.\
See [Render Modes below](#render-modes).
:::

## Send Views

Use `SendView()` to send a view.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendView(views.View{Name: "Welcome"}) // Sends view "Welcome".
}
```

The **Name** of the view will be used to lookup the view component exported by **app/exports/server.ts** and/or **app/exports/client.ts**.

:::caution
If the view **Name** is not present in neither `app/exports/server.ts` or `app/exports/client.ts`, `SendView()` will fail.
:::

## Default View

There is no way to specify a "**default view**".

However, you can use `SendFileOrElse()` in order to send a file or run custom logic if it doesn't exist.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendFileOrElse(func () {                  // Attempts to send requested file, or else...
        con.SendView(views.View{Name: "Welcome"}) // ...sends view "Welcome".
    })
}
```

Usually you would map this handler to the default `GET /` pattern, which automatically captures
all unmatched requests.

```go
package main

import (
    "embed"
    "github.com/razshare/frizzante/web"
)

var server = servers.New()     // Creates a server.
var route = routes.Route{      // Creates a route.
    Pattern: "GET /",          // Sets the route's pattern.
    Handler: handlers.Welcome, // Sets the route's handler.
}

func main() {
    server.AddRoute(route)     // Adds the route to the server.
    server.Start()             // Starts the server.
}
```

## Data

Optionally, you can send data along with the views by adding a `Data` property to your `View`.

```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendView(views.View{     // Sends a view.
        Name: "Welcome",         // Sets the view's name.
        Data: map[string]string{ // Sets the view's data, which will be injected into the svelte component.
            "name": "world",     // Adds property "name" with value "world".
        },
    }) 
}
```

These properties are passed down to your view component.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    type Props = { name: string }
    let {name}:Props = $props() // Retrieves server data.
</script>

<h1>Hello {name}</h1>
```

You can also use [getContext("view")](https://svelte.dev/docs/svelte/context) to retrieve your data.

```svelte
//app/lib/views/Hello.svelte
<script lang="ts">
    import type { View } from "$frizzante/types.ts"
    const view = getContext("view") as View<{ name: string }> // Retrieves the same server data, 
                                                              // but can be used anywhere in the project
                                                              // regardless of the component hierarchy.
</script>

<h1>Hello {view.data.name}</h1>
```

## Render Modes

You can choose how to render views with the `RenderMode` property.

### RenderModeFull

Using `RenderModeFull`, the view is rendered on both the server and the client.<br/>
This is the **default** mode.
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendView(views.View{              // Sends a view.
        Name: "Welcome",                  // Sets the view's name.
        RenderMode: views.RenderModeFull, // Renders the view on server and client.
    })
}
```

### RenderModeServer

Using `RenderModeServer`, the view is rendered only on the server.<br/>
You'll have to deal away with apis such as [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API); 
your new best friend is [form](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form).
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendView(views.View{                // Sends a view.
        Name: "Welcome",                    // Sets the view's name.
        RenderMode: views.RenderModeServer, // Renders the view onl on the server.
    })
}
```
:::tip
While using `RenderModeServer` the view won't serve a JavaScript bundle,
but you can still use the `<svelte:head>` special
tag in order to load scripts dynamically.
```svelte
<svelte:head>
    <script type="text/javascript" src="https://some.cdn/file.js" />
</svelte:head>
```
:::


### RenderModeClient

Using `RenderModeClient`, the view is rendered only on the client by loading a JavaScript bundle asynchronously.
```go
//lib/handlers/welcome.go
package lib

import (
    "github.com/razshare/frizzante/connections"
    "github.com/razshare/frizzante/views"
)

func Welcome(con *connections.Connection) {
    con.SendView(views.View{                // Sends a view.
        Name: "Welcome",                    // Sets the view's name.
        RenderMode: views.RenderModeClient, // Renders the view onl on the client.
    })
}
```

:::tip
You can combine any of these render modes with adaptive hyperlinks and forms.
Read more about [web standards](../web-standards).
:::
