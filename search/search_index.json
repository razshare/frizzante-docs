{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Create a new project by cloning the starter template</p> Bash<pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; \\\nrm frizzante-starter/.git -fr\n</code></pre> <p>Then navigate to it</p> Bash<pre><code>cd frizzante-starter\n</code></pre> <p>Configure project</p> Bash<pre><code>make configure\n</code></pre> <p>Update dependencies</p> Bash<pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have Go, build-essential and Bun installed. If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Then you can start the server with</p> Bash<pre><code>make start\n</code></pre> <p>Enter development mode with</p> Bash<pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> Bash<pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>You can create apis with <code>f.ServerWithApiBuilder()</code></p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Handle request.\n    })\n}\n</code></pre></p> <p>Where <code>f.ApiWithPattern()</code> routes the api using a pattern and <code>f.ApiWithRequestHandler()</code> sets the request handler.</p> <p>Note</p> <p>You can route the same api to multiple patterns Go<pre><code>f.ApiWithPattern(api, \"GET /\")\nf.ApiWithPattern(api, \"GET /api/greeting\")\nf.ApiWithRequestHandler(api, handle)\n</code></pre></p>"},{"location":"api/#send","title":"Send","text":"<p>You can send out a message with <code>f.ResponseSendMessage()</code></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        f.ResponseSendMessage(response, \"hello\")\n    })\n}\n</code></pre></p>"},{"location":"api/#path","title":"Path","text":"<p>You can define path fields in your pattern using the curly  braces format <code>{}</code> and retrieve fields with <code>f.RequestReceivePath()</code>.</p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        name := f.RequestReceivePath(request, \"name\")\n        f.ResponseSendMessage(response, \"hello \"+name)\n    })\n}\n</code></pre></p>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>f.ResponseSendStatus()</code></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        f.ResponseSendStatus(response, 404)\n        f.ResponseSendMessage(response, \"Resource not found, sorry.\")\n    })\n}\n</code></pre></p> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header","title":"Header","text":"<p>You can retrieve header fields with <code>f.RequestReceiveHeader()</code> and send out header fields with <code>f.ResponseSendHeader()</code>.</p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        contentType := f.RequestReceiveHeader(request, \"Content-Type\")\n        if \"application/xml\" != contentType {\n            f.ResponseSendStatus(response, 400)\n            f.ResponseSendHeader(response, \"Content-Length\", \"69\")\n            f.ResponseSendMessage(response, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n            return\n        }\n\n        f.ResponseSendStatus(response, 404)\n        f.ResponseSendHeader(response, \"Content-Length\", \"26\")\n        f.ResponseSendMessage(response, \"Resource not found, sorry.\")\n    })\n}\n</code></pre></p> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>f.RequestReceiveQuery()</code></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        name := f.RequestReceiveQuery(request, \"name\")\n        f.ResponseSendMessage(response, \"hello \"+name)\n    })\n}\n</code></pre></p>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>f.RequestReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        form := f.RequestReceiveForm(request)\n        name := form.Get(\"name\")\n        f.ResponseSendMessage(response, \"hello \"+name)\n    })\n}\n</code></pre></p> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>f.RequestReceiveJson[T]()</code>.</p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        person, _ := f.RequestReceiveJson[Person](request)\n        f.ResponseSendMessage(response, \"hello \"+person.name)\n    })\n}\n</code></pre></p> <p>Where <code>Person</code> would be a struct</p> Go<pre><code>type Person struct {\n    Name string\n}\n</code></pre>"},{"location":"api/#conventions","title":"Conventions","text":"<p>Api functions should be created under <code>lib/api/{name}.go</code>, where <code>{name}</code> is the name of the api.</p>"},{"location":"cancellation/","title":"Cancellation","text":"<p>Always track cancelled requests while streaming events, web sockets, executing long running tasks or expensive tasks in your request handlers.</p> <p>You can detect cancelled requests with <code>f.RequestReceiveCancellation()</code>.</p> <p>For example using sse</p> <p><code>main.go</code></p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc requestIsAlive(request *f.Request) *bool {\n    // Assuming the connection is alive when starting\n    // and initializing state.\n    value := true\n    go func() {\n        // Wait for cancellation.\n        &lt;-f.RequestReceiveCancellation(request)\n\n        // Update state after cancellation.\n        value = false\n    }()\n\n    // Return state pointer.\n    return &amp;value\n}\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /welcome\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Get a pointer to the connection status.\n        alive := requestIsAlive(request)\n\n        // Upgrade to server sent events.\n        withEventName := f.ResponseSendSseUpgrade(response)\n        withEventName(\"server-time\")\n\n        // Continuously check if connection is still alive.\n        for *alive {\n            f.ResponseSendMessage(response, fmt.Sprintf(\"Server time is %s\", time.Now()))\n        }\n    })\n}\n</code></pre></p> <p>or using web sockets</p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc requestIsAlive(request *f.Request) *bool {\n    // Assuming the connection is alive when starting\n    // and initializing state.\n    value := true\n    go func() {\n        // Wait for cancellation.\n        &lt;-f.RequestReceiveCancellation(request)\n\n        // Update state after cancellation.\n        value = false\n    }()\n\n    // Return state pointer.\n    return &amp;value\n}\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /welcome\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Get a pointer to the connection status.\n        alive := requestIsAlive(request)\n\n        // Upgrade to web sockets.\n        f.ResponseSendWsUpgrade(response)\n\n        // Continuously check if connection is still alive.\n        for *alive {\n            f.ResponseSendMessage(response, \"hello\")\n            msg := f.RequestReceiveMessage(request)\n            fmt.Printf(\"RequestReceived message `%s`.\\n\", msg)\n        }\n    })\n}\n</code></pre></p>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>f.ServerWithCertificateAndKey()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Setup certificate.\n    f.ServerWithCertificateAndKey(server, \"cert.pem\", \"key.pem\")\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"guards/","title":"Guards","text":"<p>Use <code>f.ApiWithGuardHandler()</code> or <code>f.PageWithGuardHandler()</code> to add a new guard.</p> <p>Note</p> <p>A guard is a function that handles incoming requests before they reach any of your actual api and page handlers. Guards can decide which requests should pass through and which request should be rejected.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.PageWithGuardHandler(api, func(request *f.Request, response *f.Response, pass func()) {\n        // Handle guard.\n        pass()\n    })\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Handle request.\n    })\n}\n</code></pre></p> <p>Use <code>pass()</code> to let the current request pass through.</p> <p>Warning</p> <p>Failing to invoke <code>pass()</code> means the current request will be rejected.</p>"},{"location":"guards/#conventions","title":"Conventions","text":"<p>Guards should be created under <code>lib/guards/{name}.go</code>, where <code>{name}</code> is the name of the guard.</p>"},{"location":"make/","title":"Make","text":"<p>You can use <code>go run lib/make/main.go</code> to create apis and pages from your terminal.</p>"},{"location":"make/#api","title":"Api","text":"<p>Use <code>go run lib/make/main.go -api -name=\"{name}\"</code> to create an api, where <code>{name}</code> is the human readable name of the api.</p> <p>Example</p> <p>Bash<pre><code>go run lib/make/main.go -api -name=\"login\"\n</code></pre> This will create a <code>lib/api/login.go</code> file.</p> <p>As an alternative, you can use the provided makefile command</p> Bash<pre><code>make api\n</code></pre>"},{"location":"make/#pages","title":"Pages","text":"<p>Use <code>go run lib/make/main.go -page -name=\"{name}\"</code> to create a page, where <code>{name}</code> is the human readable name of the page.</p> <p>Example</p> <p>Bash<pre><code>go run lib/make/main.go -page -name=\"welcome\"\n</code></pre> This will create files <code>lib/page/welcome.go</code> and <code>lib/components/views/Welcome.svelte</code>.</p> <p>As an alternative, you can use the provided makefile command</p> Bash<pre><code>make page\n</code></pre>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> XML<pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a JavaScript bundle, which once loaded, takes over the Dom.</p> <p>Although more powerful and versatile, this mode adds some complexity to your application.</p>"},{"location":"pages/","title":"Pages","text":"<p>Before creating a page, you need to create a view, which are just <code>.svelte</code> components. These components must be located under <code>lib/components/views</code>.</p> <p>Note</p> <p>See the views section for more details.</p> <p>Views can be referred to by your Go code using their name relative to <code>lib/components/views</code>.</p> <p>Example</p> <p>A view located at <code>lib/components/views/Welcome.svelte</code> will be identified by <code>Welcome</code>.</p> <p>Subdirectories are joined by <code>.</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A view located at <code>lib/components/views/about/Me.svelte</code> will be identified by <code>about.Me</code>.</p> <p>After you've created your view, you can add a page to the server with <code>f.ServerWithPageBuilder()</code> in your <code>main.go</code> file.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Pages.\n    f.ServerWithPageBuilder(server, pages.Welcome)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/pages/Welcome.go</code> Go<pre><code>package pages\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc Welcome(page *f.Page) {\n    // Build page.\n    f.PageWithPath(page, \"/Welcome\")\n    f.PageWithView(page, f.ViewReference(\"Welcome\")) // This references the file \n                                                     // \"lib/components/views/Welcome.svelte\"\n    f.PageWithBaseHandler(page, func(request *f.Request, response *f.Response, view *f.View) {\n        // Show page.\n    })\n    f.PageWithActionHandler(page, func(request *f.Request, response *f.Response, view *f.View) {\n        // Modify state.\n    })\n}\n</code></pre></p> <p><code>lib/components/views/Welcome.svelte</code> HTML<pre><code>&lt;h1&gt;Welcome to Frizzante.&lt;/h1&gt;\n</code></pre></p> <p>In your setup function, <code>f.PageWithPath()</code> sets the path of your page  and <code>f.PageWithView()</code> sets the view of your page.</p> <p>Note</p> <p>You can map many paths to one view. Go<pre><code>f.PageWithPath(page, \"/\")\nf.PageWithPath(page, \"/api/greeting\")\nf.PageWithView(page, f.ViewReference(\"Welcome\"))\n</code></pre></p> <p>Danger</p> <p>You cannot map many views to one path. Go<pre><code>f.PageWithPath(page, \"/\")\nf.PageWithView(page, f.ViewReference(\"Welcome\"))  // &lt;-- This is not allowed,\nf.PageWithView(page, f.ViewReference(\"Login\"))    // &lt;-- two views are exposed by the same path.\n</code></pre></p> <p><code>f.PageWithBaseHandler()</code> sets the page base handler</p> <p>Note</p> <p>A base page handler is a function that  handles requests to the <code>GET</code> http verb. This function usually does not modify the state,  it just renders information to the screen.</p> <p><code>f.PageWithActionHandler()</code> sets the page action handler</p> <p>Note</p> <p>An action page handler is a function that  handles requests to the <code>POST</code> http verb. This function usually modifies the state and  sometimes redirects to some other page.</p> <p>Each page exposes a <code>Data</code> map, which is automatically injected into the view</p> Go<pre><code>func(request *f.Request, response *f.Response, view *f.View) {\n    f.ViewWithData(view, \"name\", \"world\")\n}\n</code></pre> <p>These <code>Data</code> fields can be retrieved from your svelte components with getContext(\"data\").</p> HTML<pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>Context <code>data</code> is created with $state(), hence it is reactive.</p> <p>Note</p> <p>A page is treated like an api under the hood, which means it  has access to the same features.  You can receives path fields with <code>f.RequestReceivePath()</code>,  queries with <code>f.RequestReceiveQuery()</code>, forms with <code>f.RequestReceiveForm()</code>, json objects with <code>f.RequestReceiveJson[T]()</code> and so on.</p> <p>Danger</p> <p>While rendering a page, you shouldn't send content to the client directly  using <code>f.ResponseSend*</code> functions,  like <code>f.ResponseSendMessage()</code>, <code>f.ResponseSendJson()</code>.  ResponseSending content directly to the client will break the HTML document structure by prepending  the content to the actual view.  There are some use cases where sending content directly is useful, like debugging.</p> <p>Note</p> <p>Functions that send the status and header fields, like <code>f.ResponseSendStatus()</code>, <code>f.ResponseSendHeader()</code>, are safe to use.</p>"},{"location":"pages/#other-details","title":"Other details","text":"<p>Page functions should be created under <code>lib/pages/{name}.go</code>, where <code>{name}</code> is the name of the page.</p>"},{"location":"server-sent-events/","title":"Server sent events","text":"<p>You can upgrade http requests to server sent events with <code>f.ResponseSendSseUpgrade()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Upgrade to server sent events.\n        withEventName := f.ResponseSendSseUpgrade(response)\n\n        for {\n            // Send to channel-1.\n            withEventName(\"channel-1\")\n            f.ResponseSendMessage(response, \"This is a message for channel-1\")\n\n            // Send to channel-2.\n            withEventName(\"channel-2\")\n            f.ResponseSendMessage(response, \"This is a message for channel-2\")\n            f.ResponseSendMessage(response, \"This is another message for channel-2\")\n\n            // Send to channel-1.\n            withEventName(\"channel-1\")\n            f.ResponseSendMessage(response, \"Back to channel-1\")\n\n            // Sleep for a bit.\n            time.Sleep(time.Second)\n        }\n    })\n}\n</code></pre></p> <p>Set the name of the current event with <code>withEventName</code>,  then start sending content to the client with the usual <code>f.ResponseSendMessage()</code> and <code>f.ResponseSendJson()</code>.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the event stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming events. Read more about cancellation here.</p> <p>Note</p> <p>The default event name is <code>message</code>.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>f.ServerCreate()</code> and start it with <code>f.ServerStart()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerStart(server)\n}\n</code></pre></p> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerStart(server)\n}\n</code></pre></p> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>f.ServerWithHostName()</code> and <code>f.ServerWithPortNumber()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerWithPort(server, 8989)\n    f.ServerWithHostName(server, \"192.168.0.123\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerStart(server)\n}\n</code></pre></p>"},{"location":"sessions/","title":"Sessions","text":"<p>Use <code>f.SessionStart()</code> to start the session.</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    // Start session.\n    state := f.SessionStart(request, response)\n\n    // Modify state.\n    f.SessionSetString(session, \"name\", \"World\")\n}\n</code></pre>"},{"location":"sessions/#session-builder","title":"Session builder","text":"<p>By default all sessions are saved to a <code>.sessions</code> directory on your disk.</p> <p>This is the default behavior, which is useful for quick debugging.</p> <p>You can customize this behavior by  providing your own session builder.</p> <p>Note</p> <p>A session builder is a function that builds (or retrieves) a session's state. It provides the basic mechanisms for checking, getting, setting properties and a destroyer function, which specifies what should happen when a session is \"destroyed\".</p> <p>Use <code>f.ServerWithSessionBuilder()</code> to set the server's session builder.</p> <p><code>main.go</code> Go<pre><code>import f \"github.com/razshare/frizzante\"\n\npackage main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/api\"\n    \"main/lib/pages\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\nvar memory = map[string]map[string][]byte{}\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithNotifier(server, notifier)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n\n    // Sessions.\n    f.ServerWithSessionBuilder(server, func(session *f.Session) {\n        sessionId := f.SessionId(session)\n        memory[sessionId] = map[string][]byte{}\n\n        f.SessionWithGetHandler(session, func(key string) []byte {\n            return memory[sessionId][key]\n        })\n\n        f.SessionWithSetHandler(session, func(key string, value []byte) {\n            memory[sessionId][key] = value\n        })\n\n        f.SessionWithHasHandler(session, func(key string) bool {\n            _, hasKey := memory[sessionId][key]\n            return hasKey\n        })\n\n        f.SessionWithDestroyHandler(session, func() {\n            delete(memory, sessionId)\n        })\n    })\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    //Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(api, \"GET /\")\n    f.ApiWithRequestHandler(api, func(request *f.Request, response *f.Response) {\n        // Start session.\n        state := f.SessionStart(request, response)\n\n        // Modify state.\n        f.SessionSetString(session, \"name\", \"World\")\n    })\n}\n</code></pre></p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>f.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p>"},{"location":"views/","title":"Views","text":"<p>Views are <code>.svelte</code> files located under <code>lib/components/views</code>.</p> <p>Here's an example of a view located at <code>lib/components/views/Welcome.svelte</code></p> HTML<pre><code>&lt;script&gt;\n    let name = \"world\"\n&lt;/script&gt;\n\nHello {name}!\n</code></pre> <p>Note</p> <p>Views are used by Go pages to render content. See the pages section for more details.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to web sockets with <code>f.ResponseSendWsUpgrade()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, api.MyApi)\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre></p> <p><code>lib/api/MyApi.go</code> Go<pre><code>package api\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc MyApi(api *f.Api) {\n    // Build api.\n    f.ApiWithPattern(\"GET /\")\n    f.ApiWithRequestHandler(func(request *f.Request, response *f.Response) {\n        // Upgrade to web sockets.\n        f.ResponseSendWsUpgrade(response)\n\n        for {\n            // Send message.\n            f.ResponseSendMessage(response, \"hello\")\n\n            // Wait for incoming message.\n            msg := f.RequestReceiveMessage(request)\n\n            // Log.\n            fmt.Printf(\"RequestReceived message `%s`.\\n\", msg)\n        }\n    })\n}\n</code></pre></p> <p>Use the usual <code>f.ResponseSendMessage()</code> to send a raw text message and <code>f.ResponseSendJson()</code> to send a json message to the client.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the web socket stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming web sockets. Read more about cancellation here.</p>"}]}