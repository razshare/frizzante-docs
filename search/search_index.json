{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Make sure you have Go and Bun installed.</p> <p>Note</p> <p>If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Create a new project using the starter template.</p> <pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; cd frizzante-starter &amp;&amp; rm .git -fr\n</code></pre> <p>Update dependencies</p> <pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have build-essential installed <pre><code>sudo apt install build-essential\n</code></pre></p> <p>Then you can start the server with</p> <pre><code>make start\n</code></pre> <p>You can enter dev mode with</p> <pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> <pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>You can route apis with <code>frz.ServerRouteApi()</code></p> <pre><code>frz.ServerRouteApi(server, \"GET /\",\n    func(_ *frz.Server, _ *frz.Request, res *frz.Response) {\n        frz.SendEcho(res, \"hello\")\n    },\n)\n</code></pre> <p>The above example listens for requests at <code>GET /</code> and responds with <code>hello</code> as <code>text/plain</code>.</p>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>frz.SendStatus()</code></p> <pre><code>frz.ServerRouteApi(server, \"GET /\",\n    func(_ *frz.Server, _ *frz.Request, res *frz.Response) {\n        frz.SendStatus(res, 404)\n        frz.SendEcho(res, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header-fields","title":"Header fields","text":"<p>You can retrieve header fields with <code>frz.ReceiveHeader()</code> and send out header fields with <code>frz.SendHeader()</code>.</p> <pre><code>frz.ServerRouteApi(server, \"GET /\",\n    func(_ *frz.Server, req *frz.Request, res *frz.Response) {\n        contentType := frz.ReceiveHeader(req, \"Content-Type\")\n        if \"application/xml\" != contentType {\n            frz.SendStatus(res, 400)\n            frz.SendHeader(res, \"Content-Length\", \"69\")\n            frz.SendEcho(res, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n            return\n        }\n\n        frz.SendStatus(res, 404)\n        frz.SendHeader(res, \"Content-Length\", \"26\")\n        frz.SendEcho(res, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#path-fields","title":"Path fields","text":"<p>You can define path fields via the <code>{parameter}</code> syntax, the name of the parameter wrapped in curly braces.</p> <p>You can then retrieve the value of the path field with <code>frz.ReceivePath()</code></p> <pre><code>frz.ServerRouteApi(server, \"GET /About/{Name}\",\n    func(_ *frz.Server, req *frz.Request, res *frz.Response) {\n        name := frz.ReceivePath(req, \"Name\")\n        frz.SendEcho(res, \"hello \")\n        frz.SendEcho(res, name)\n    },\n)\n</code></pre>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>frz.ReceiveQuery()</code></p> <pre><code>frz.ServerRouteApi(server, \"GET /About\",\n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        name := frz.ReceiveQuery(request, \"Name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>frz.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <pre><code>frz.ServerRouteApi(server, \"POST /About\",\n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        form := frz.ReceiveForm(request)\n        name := form.Get(\"Name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>frz.ReceiveJson()</code>.</p> <p>This function is a bit different that the others because it doesn't return a value, instead it takes in an object and projects the contents of the json onto said object.</p> <pre><code>type Person struct {\n    Name string\n}\n\nfrz.ServerRouteApi(server, \"POST /About\",\n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        person := &amp;Person{}\n        form := frz.ReceiveJson(request, person)\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, person.Name)\n    },\n)\n</code></pre>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>frz.ServerWithCertificateAndKey()</code>.</p> <pre><code>frz.ServerWithCertificateAndKey(srv, \"cert.pem\", \"key.pem\")\n</code></pre> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> <pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a javaScript bundle, which once loaded, takes over the Dom.</p>"},{"location":"pages/","title":"Pages","text":"<p>Pages are just svelte components located in the <code>lib/pages</code> directory.</p> <p>You can refer to these pages by their relative file names.</p> <p>Note</p> <p>The <code>.svelte</code> extension is optional.</p> <p>Example</p> <p>A page located at <code>lib/pages/Welcome.svelte</code> will be identified by <code>Welcome</code>.</p> <p>Subdirectories are joined by <code>::</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A page located at <code>lib/pages/about/User.svelte</code> will be identified by <code>about::User</code>.</p>"},{"location":"pages/#mapping-a-page","title":"Mapping a page","text":"<p>You can route pages with <code>frz.ServerRoutePage()</code></p> <pre><code>frz.ServerRoutePage(srv, \"/Welcome\", \"Welcome\", Welcome)\n</code></pre> <p>Mapping a page requires </p> <ul> <li>a path, <code>/Welcome</code> in this case, </li> <li>a page id, <code>Welcome</code> in this case,</li> <li>a page function, also called <code>Welcome</code> in this case.</li> </ul> <p>This page function must take in a server, request, response and a page</p> <pre><code>func Welcome(_ *frz.Server, _ *frz.Request, _ *frz.Response, p *frz.Page) {\n    frz.PageWithRenderMode(frz.RenderModeServer)\n    frz.PageWithData(p, \"Name\", \"world\")\n}\n</code></pre> <p>In this example, the page function is using <code>frz.PageWithRenderMode()</code>  to configure the rendering mode,  which can be <code>frz.RenderModeServer</code>, <code>frz.RenderModeClient</code> or <code>frz.RenderModeFull</code>, and it's passing a <code>Name</code> property with the value of <code>world</code> to the  underlying <code>Welcome</code> page which can be retrieved  by any of your components with getContext(\"Data\").</p> <pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"Data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>See overview page for more details on rendering modes.</p> <p>Note</p> <p>Default rendering mode is <code>frz.RenderModeFull</code>.</p> <p>Note</p> <p>Context <code>Data</code> is created with $state(), hence it is reactive.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>frz.ServerCreate()</code> and start it with <code>frz.ServerStart()</code>.</p> <pre><code>package main\nimport frz \"github.com/razshare/frizzante\"\n\nfunc main() {\n    srv := frz.ServerCreate()\n    frz.ServerStart(srv)\n}\n</code></pre> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <pre><code>package main\nimport \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := frz.ServerCreate()\n    frz.ServerWithEmbeddedFileSystem(srv, dist)\n    frz.ServerStart(srv)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>frz.ServerWithHostname()</code> and <code>frz.ServerWithPortNumber()</code>.</p> <pre><code>package main\nimport \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := frz.ServerCreate()\n    frz.ServerWithPort(srv, 8989)\n    frz.ServerWithHostName(srv, \"192.168.0.123\")\n    frz.ServerWithEmbeddedFileSystem(srv, dist)\n    frz.ServerStart(srv)\n}\n</code></pre>"},{"location":"sessions/","title":"Sessions","text":"<p>Use <code>frz.SessionStart()</code> to start a session.</p> <pre><code>frz.ServerRouteApi(server, \"GET /\",\n    func(_ *frz.Server, req *frz.Request, res *frz.Response) {\n        get, set, unset := frz.SessionStart(req, res)\n    },\n)\n</code></pre> <p><code>frz.SessionStart()</code> always succeeds and it always returns three functions, get, set and unset.</p> <p>Note</p> <p>The reason <code>frz.SessionStart()</code> always succeeds is because it will automatically create a new session if none is found. The new session does not retain any data from the previous session.</p>"},{"location":"sessions/#get","title":"Get","text":"<p>Use <code>get()</code> to retrieve a session property.</p> <pre><code>get, _, _ := frz.SessionStart(req, res)\nusername := get(\"Username\", \"guest\").(string)\n</code></pre>"},{"location":"sessions/#set","title":"Set","text":"<p>Use <code>set()</code> to create or update a session property.</p> <pre><code>_, set, _ := frz.SessionStart(req, res)\nset(\"Username\", \"frizzante\")\n</code></pre>"},{"location":"sessions/#unset","title":"Unset","text":"<p>Use <code>unset()</code> to remove a session property.</p> <pre><code>_, _, unset := frz.SessionStart(req, res)\nunset(\"Username\")\n</code></pre>"},{"location":"sessions/#session-operator","title":"Session operator","text":"<p>You can overwrite the default in-memory session operator and provide  your own <code>get</code>, <code>set</code>, <code>unset</code>, <code>validate</code> and <code>destroy</code> functions.</p> <p>Use <code>frz.ServerWithSessionOperator()</code> to overwrite the default session operator</p> <pre><code>frz.ServerWithSessionOperator(srv, func(id string) (\n    get func(key string, defaultValue any) (value any),\n    set func(key string, value any),\n    unset func(key string),\n    validate func() bool,\n    destroy func(),\n) {\n    get = func(key string, defaultValue any) (value any) {\n        // ...\n    }\n\n    set = func(key string, value any) {\n        // ...\n    }\n\n    unset = func(key string) {\n        // ...\n    }\n\n    validate = func() {\n        // ...\n    }\n\n    destroy = func() {\n        // ...\n    }\n    return\n})\n</code></pre> <p>Note</p> <p><code>Validate</code> and <code>destroy</code> are used by the server internally  to manage and destroy sessions that are no longer valid.</p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>frz.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p> <p>Instead, <code>frz.ServerWithSessionOperator()</code> has complete control over the lifetime of any session.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to web sockets with <code>frz.SendWebSocketUpgrade()</code>.</p> <pre><code>frz.ServerRouteApi(srv, \"GET /\",\n    func(_ *frz.Server, req *frz.Request, res *frz.Response) {\n        frz.SendWebSocketUpgrade(res, func() {\n            for {\n                frz.SendEcho(res, \"hello\")\n                msg := frz.ReceiveMessage(req)\n                fmt.Printf(\"Received message `%s`.\\n\", msg)\n            }\n        })\n    },\n)\n</code></pre> <p>Note</p> <p>Once the callback function returns,  for example by exiting the <code>for</code> loop,  the web socket connection ends.</p>"}]}