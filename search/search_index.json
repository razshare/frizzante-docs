{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Make sure you have Go and Bun installed.</p> <p>Note</p> <p>If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Create a new project using the starter template.</p> <pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; cd frizzante-starter\n</code></pre> <p>Configure the project</p> <pre><code>make configure\n</code></pre> <p>Note</p> <p>Configuring the project will also update dependencies. Use <code>make update</code> to only update dependencies.</p> <p>Then you can start the server with</p> <pre><code>make start\n</code></pre> <p>You can enter dev mode with</p> <pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> <pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>frz.ServerWithCertificateAndKey()</code>.</p> <pre><code>frz.ServerWithCertificateAndKey(server, \"cert.pem\", \"key.pem\")\n</code></pre> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> <pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a javaScript bundle, which once loaded, takes over the Dom.</p>"},{"location":"request-handlers/","title":"Request handlers","text":"<p>You can listen for requests with <code>frz.ServerWithRequestHandler()</code>.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        frz.SendEcho(response, \"hello\")\n    },\n)\n</code></pre> <p>The above example listens for requests at <code>GET /</code> and responds with <code>hello</code> as <code>text/plain</code>.</p>"},{"location":"request-handlers/#status","title":"Status","text":"<p>You can send out a status code with <code>frz.SendStatus()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        frz.SendStatus(response, 404)\n        frz.SendEcho(response, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"request-handlers/#header-fields","title":"Header fields","text":"<p>You can retrieve header fields with <code>frz.ReceiveHeader()</code> and send out header fields with <code>frz.SendHeader()</code>.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        contentType := frz.ReceiveHeader(request, \"Content-Type\")\n        if \"application/xml\" != contentType {\n            frz.SendStatus(response, 400)\n            frz.SendHeader(response, \"Content-Length\", \"69\")\n            frz.SendEcho(response, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n            return\n        }\n\n        frz.SendStatus(response, 404)\n        frz.SendHeader(response, \"Content-Length\", \"26\")\n        frz.SendEcho(response, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"request-handlers/#path-fields","title":"Path fields","text":"<p>You can define path fields via the <code>{parameter}</code> syntax, the name of the parameter wrapped in curly braces.</p> <p>You can then retrieve the value of the path field with <code>frz.ReceivePath()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /about/{name}\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        name := frz.ReceivePath(request, \"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre>"},{"location":"request-handlers/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>frz.ReceiveQuery()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        name := frz.ReceiveQuery(request, \"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre>"},{"location":"request-handlers/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>frz.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"POST /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        form := frz.ReceiveForm(request)\n        name := form.Get(\"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"request-handlers/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>frz.ReceiveJson()</code>.</p> <p>This function is a bit different that the others because it doesn't return a value, instead it takes in an object and projects the contents of the json onto said object.</p> <pre><code>type Person struct {\n    Name string `json:\"name\"`\n}\n\nfrz.ServerWithRequestHandler(\n    server,\n    \"POST /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        person := &amp;Person{}\n        form := frz.ReceiveJson(request, person)\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, person.Name)\n    },\n)\n</code></pre>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>frz.CreateServer()</code> and start it with <code>frz.ServerStart()</code>.</p> <pre><code>import frz \"github.com/razshare/frizzante\"\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerStart(server)\n}\n</code></pre> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>www/dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <pre><code>import \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed www/dist/*/**\nvar efs embed.FS\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerWithEmbeddedFileSystem(server, efs)\n    frz.ServerStart(server)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>frz.ServerWithHostname()</code> and <code>frz.ServerWithPortNumber()</code>.</p> <pre><code>import \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed www/dist/*/**\nvar efs embed.FS\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerWithPort(server, 8989)\n    frz.ServerWithHostName(server, \"192.168.0.123\")\n    frz.ServerWithEmbeddedFileSystem(server, efs)\n    frz.ServerStart(server)\n}\n</code></pre>"},{"location":"svelte-pages/","title":"Svelte pages","text":"<p>Pages are just svelte components located in the <code>pages</code> directory.</p> <p>You can refer to these pages by their relative file names.</p> <p>Note</p> <p>The <code>.svelte</code> extension is optional.</p> <p>Example</p> <p>A page located at <code>pages/welcome.svelte</code> will be identified by <code>welcome</code>.</p> <p>Subdirectories are joined by <code>::</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A page located at <code>pages/about/user.svelte</code> will be identified by <code>about::user</code>.</p>"},{"location":"svelte-pages/#mapping-a-page","title":"Mapping a page","text":"<p>You can map pages with <code>frz.ServerWithSveltePage()</code></p> <pre><code>frz.ServerWithSveltePage(server, \"GET /welcome\", \"welcome\", configure)\n</code></pre> <p>Mapping a page requires </p> <ul> <li>a pattern, <code>GET /welcome</code> in this case, </li> <li>a page id, <code>welcome</code> in this case,</li> <li>a configuration provider, called <code>configure</code> in this case.</li> </ul> <p>This configuration provider is a function that must take in a request and return a configuration</p> <pre><code>func configure(_ *frz.Request) *frz.SveltePageConfiguration {\n    return &amp;frz.SveltePageConfiguration{\n        Render: frz.ModeFull,\n        Data: map[string]interface{}{\n            \"name\": \"world\",\n        },\n    }\n}\n</code></pre> <p>The resulting configuration defines a required <code>Render</code> property, indicating the rendering mode,  which can be <code>frz.ModeServer</code>, <code>frz.ModeClient</code> or <code>frz.ModeFull</code> and an optional <code>Data</code> property, which can be retrieved by any of your components with getContext(\"data\").</p> <p>Note</p> <p>See overview page for more details on rendering modes.</p> <pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>Context <code>data</code> is created with $state(), hence it is reactive.</p> <p>Warning</p> <p>Context keys <code>query</code>, <code>path</code>, and <code>form</code> are reserved. See next sections.</p>"},{"location":"svelte-pages/#query-fields","title":"Query fields","text":"<p>Query fields are automatically injected in the context of the svelte page that's being rendered.</p> <p>Say, for example, that you've mapped your svelte page to <code>GET /about</code> and some client requests <code>GET/about?name=world</code>.</p> <p>You can retrieve the <code>name</code> query field with <code>getContext(\"data\").query.name</code>.</p> <pre><code>// main.go\nfrz.ServerWithSveltePage(server, \"GET /about\", \"about\", configure)\n</code></pre> <pre><code>&lt;!--pages/about.svelte--&gt;\n&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.query.name}&lt;/h1&gt;\n</code></pre>"},{"location":"svelte-pages/#path-fields","title":"Path fields","text":"<p>Path fields are automatically injected in the context of the svelte page that's being rendered.</p> <p>Say, for example, that you've mapped your svelte page to <code>GET /about/{name}</code>.</p> <p>You can retrieve the <code>{name}</code> path field with <code>getContext(\"data\").path.name</code>.</p> <pre><code>// main.go\nfrz.ServerWithSveltePage(server, \"GET /about/{name}\", \"about\", configure)\n</code></pre> <pre><code>&lt;!--pages/about.svelte--&gt;\n&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.path.name}&lt;/h1&gt;\n</code></pre>"},{"location":"svelte-pages/#form-fields","title":"Form fields","text":"<p>Form fields are automatically injected in the context of the svelte page that's being rendered.</p> <p>All incoming form fields are mapped into <code>getContext(\"data\").form</code>.</p> <pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.form.name}&lt;/h1&gt;\n</code></pre> <p>However, when dealing with forms, you will most likely want to update your state in-place,  so for that reason it is best to configure each page individually.</p> <p>Note</p> <p>If you're coming from the MVC world,  you can think of configuration providers as Controllers.</p> <p>The following is a more in-depth example using form fields.</p> <pre><code>// main.go\n\n// GET /about\nfrz.ServerWithSveltePage(server, \"GET /about\", \"about\",\n    func(_ *frz.Request) *frz.SveltePageConfiguration {\n        return &amp;frz.SveltePageConfiguration{Render: frz.ModeFull}\n    },\n)\n\n// POST /about\nfrz.ServerWithSveltePage(server, \"POST /about\", \"about\",\n    func(request *frz.Request) *frz.SveltePageConfiguration {\n        form := frz.ReceiveForm(request)\n        name := form.Get(\"name\")\n\n        if len(name) &lt; 2 {\n            return &amp;frz.SveltePageConfiguration{\n                Render: frz.ModeFull,\n                Data:   map[string]interface{}{\"error\": \"Name must be at least 2 characters long.\"},\n            }\n        }\n\n        return &amp;frz.SveltePageConfiguration{\n            Render: frz.ModeFull,\n            Data:   map[string]interface{}{\"name\": name},\n        }\n    },\n)\n</code></pre> <pre><code>&lt;!--pages/about.svelte--&gt;\n&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n{#if data.error}\n    &lt;h3&gt;Error&lt;/h3&gt;\n    &lt;span&gt;{data.error}&lt;/span&gt;\n{:else if data.name}\n    &lt;h3&gt;Welcome, {data.name}!&lt;/h3&gt;\n{:else}\n    &lt;form method=\"POST\" action=\"?\"&gt;\n        &lt;label for=\"name\"&gt;\n            &lt;span&gt;Name&lt;/span&gt;\n            &lt;input type=\"text\" id=\"name\" name=\"name\" value=\"\" /&gt;\n        &lt;/label&gt;\n        &lt;br/&gt;\n\n        &lt;button type=\"submit\"&gt;Submit&lt;/button&gt;\n    &lt;/form&gt;\n{/if}\n</code></pre>"},{"location":"web-socket-handlers/","title":"Web socket handlers","text":"<p>You can automatically upgrade http requests to web sockets with <code>frz.ServerWithWebSocketHandler()</code>.</p> <pre><code>frz.ServerWithWebSocketHandler(server, \"GET /\", \n    func(request *frz.Request, response *frz.Response) {\n        for {\n            frz.SendEcho(response, \"hello\")\n            message := frz.ReceiveMessage(request)\n            fmt.Printf(\"Received message `%s`.\\n\", message)\n        }\n    },\n)\n</code></pre> <p>Note</p> <p>Web socket patterns must always use the <code>GET</code> verb.</p> <p>Note</p> <p>Returning from the callback function will automatically close the web socket connection. In the example above, exiting the <code>for</code> loop will automatically close the web socket connection.</p> <p>All web socket handlers are compatible with many of the same functions used by traditional request handlers.</p> <p>However, many other functions that <code>send data to the client</code> have little compatibility with web sockets because of the nature of the protocol itself.</p> <p>Note</p> <p>For example, you won't be able to send a status code to the client in your websocket loop because because by the time your callback function is executed, the underlying web socket handshake has already terminated and the status code has already been sent.</p> <p>The following is a compatibility table between web socket and request handlers.</p> Function Compatible with request handlers Compatible with web socket handlers ReceivePath Yes Yes ReceiveQuery Yes Yes ReceiveHeader Yes Yes ReceiveCookie Yes Yes ReceiveContentType Yes Yes ReceiveMessage Yes Yes ReceiveJson Yes Yes ReceiveForm Yes No VerifyContentType Yes Yes SendRedirect Yes No SendRedirectToSecure Yes No SendStatus Yes No SendHeader Yes No SendCookie Yes No SendContent Yes Yes SendEcho Yes Yes SendEmbeddedFileOrIndexOrElse Yes No SendEmbeddedFileOrElse Yes No SendFileOrIndexOrElse Yes No SendFileOrElse Yes No SendWebSocketUpgrade Yes No SendSveltePage Yes No"}]}