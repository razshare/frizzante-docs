{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Make sure you have Go and Bun installed.</p> <p>Note</p> <p>If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Create a new project using the starter template.</p> <pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; cd frizzante-starter &amp;&amp; rm .git -fr\n</code></pre> <p>Update dependencies</p> <pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have build-essential installed <pre><code>sudo apt install build-essential\n</code></pre></p> <p>Then you can start the server with</p> <pre><code>make start\n</code></pre> <p>You can enter dev mode with</p> <pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> <pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>You can route apis with <code>f.ServerWithApi()</code></p> <pre><code>f.ServerWithApi(srv, \"GET /\",\n    func(_ *f.Request, res *f.Response) {\n        f.SendEcho(res, \"hello\")\n    },\n)\n</code></pre> <p>The above example listens for requests at <code>GET /</code> and responds with <code>hello</code> as <code>text/plain</code>.</p>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>f.SendStatus()</code></p> <pre><code>f.ServerWithApi(srv, \"GET /\",\n    func(_ *f.Request, res *f.Response) {\n        f.SendStatus(res, 404)\n        f.SendEcho(res, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header-fields","title":"Header fields","text":"<p>You can retrieve header fields with <code>f.ReceiveHeader()</code> and send out header fields with <code>f.SendHeader()</code>.</p> <pre><code>f.ServerWithApi(srv, \"GET /\",\n    func(req *f.Request, res *f.Response) {\n        contentType := f.ReceiveHeader(req, \"Content-Type\")\n        if \"application/xml\" != contentType {\n            f.SendStatus(res, 400)\n            f.SendHeader(res, \"Content-Length\", \"69\")\n            f.SendEcho(res, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n            return\n        }\n\n        f.SendStatus(res, 404)\n        f.SendHeader(res, \"Content-Length\", \"26\")\n        f.SendEcho(res, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#path-fields","title":"Path fields","text":"<p>You can define path fields via the <code>{parameter}</code> syntax, the name of the parameter wrapped in curly braces.</p> <p>You can then retrieve the value of the path field with <code>f.ReceivePath()</code></p> <pre><code>f.ServerWithApi(srv, \"GET /about/{name}\",\n    func(req *f.Request, res *f.Response) {\n        name := f.ReceivePath(req, \"name\")\n        f.SendEcho(res, \"hello \")\n        f.SendEcho(res, name)\n    },\n)\n</code></pre>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>f.ReceiveQuery()</code></p> <pre><code>f.ServerWithApi(srv, \"GET /about\",\n    func(req *f.Request, res *f.Response) {\n        name := f.ReceiveQuery(req, \"name\")\n        f.SendEcho(res, \"hello \")\n        f.SendEcho(res, name)\n    },\n)\n</code></pre>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>f.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <pre><code>f.ServerWithApi(srv, \"POST /about\",\n    func(req *f.Request, res *f.Response) {\n        form := f.ReceiveForm(req)\n        name := form.Get(\"name\")\n        f.SendEcho(res, \"hello \")\n        f.SendEcho(res, name)\n    },\n)\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>f.ReceiveJson[T]()</code>.</p> <pre><code>type Person struct {\n    Name string\n}\n\nf.ServerWithApi(srv, \"POST /about\",\n    func(req *f.Request, res *f.Response) {\n        person, _ := f.ReceiveJson[Person](req)\n        f.SendEcho(res, \"hello \")\n        f.SendEcho(res, person.Name)\n    },\n)\n</code></pre>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>f.ServerWithCertificateAndKey()</code>.</p> <pre><code>f.ServerWithCertificateAndKey(srv, \"cert.pem\", \"key.pem\")\n</code></pre> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"guards/","title":"Guards","text":"<p>You can guard your pages and api by injecting arbitrary functions to execute before said pages and/or api serve the client.</p> <p>You can guard your pages with <code>f.ServerWithPageGuard()</code></p> <pre><code>f.ServerWithPageGuard(srv,\n    func(req *f.Request, res *f.Response, _ *f.Page, pass func()) {\n        f.SessionStart(req, res)\n        pass()\n    }\n)\n</code></pre> <p>You can guard your api with <code>f.ServerWithApiGuard()</code></p> <pre><code>f.ServerWithApiGuard(srv,\n    func(req *f.Request, res *f.Response, _ *f.Page, pass func()) {\n        f.SessionStart(req, res)\n        pass()\n    }\n)\n</code></pre> <p>Invoking <code>pass()</code> will let the request pass through.</p>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> <pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a javaScript bundle, which once loaded, takes over the Dom.</p>"},{"location":"pages/","title":"Pages","text":"<p>Pages are just svelte components located in the <code>lib/pages</code> directory.</p> <p>You can refer to these pages by their relative file names.</p> <p>Note</p> <p>The <code>.svelte</code> extension is optional.</p> <p>Example</p> <p>A page located at <code>lib/pages/welcome.svelte</code> will be identified by <code>welcome</code>.</p> <p>Subdirectories are joined by <code>::</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A page located at <code>lib/pages/about/welcome.svelte</code> will be identified by <code>about::welcome</code>.</p>"},{"location":"pages/#mapping-a-page","title":"Mapping a page","text":"<p>You can map pages with <code>f.ServerWithIndex()</code></p> <pre><code>f.ServerWithIndex(srv, WelcomeIndex)\n</code></pre> <p>The <code>WelcomeIndex</code> function is called an <code>index function</code>.</p> <p>Note</p> <p>In other patterns you would call this a controller.</p> <pre><code>func WelcomeIndex() (\n    page string,\n    show f.PageFunction,\n    action f.PageFunction,\n){\n    page = \"welcome\"\n    show = func (_ *f.Request, _ *f.Response, p *f.Page) {\n        f.PageWithRender(f.RenderServer)\n        f.PageWithData(p, \"name\", \"world\")\n    }\n    action = func (_ *f.Request, res *f.Response, _ *f.Page) {\n        f.SendNotFound(res)\n    }\n    return\n}\n</code></pre> <p>This index defines </p> <ol> <li>the name of the <code>page</code> to use</li> <li>what to do when the page is <code>show</code>n</li> <li>what to do then an <code>action</code> is sent to the page</li> </ol> <p>Note</p> <p>An <code>action</code> is any form sent to the page.</p> <p>In this example the index uses a page by the name of <code>welcome</code>, which is nothing more than the file <code>lib/pages/welcome.svelte</code>.</p> <p>When the index shows the page, or rather when a <code>GET</code> request comes in,  it will set the rendering mode to <code>ssr</code> (Server Side Rendering) and set a data field called <code>name</code> with a value of <code>world</code>.</p> <p>Note</p> <p>These <code>data fields</code> can be retrieved in your svelte components with getContext(\"data\"), see example bellow.</p> <p>On the other hand, when an action comes in, or rather when a <code>POST</code> request comes in, the index responds with <code>404 not found</code>.</p> <pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>See overview page for more details on rendering modes.</p> <p>Note</p> <p>Default rendering mode is <code>f.RenderFull</code>.</p> <p>Note</p> <p>Context <code>data</code> is created with $state(), hence it is reactive.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>f.ServerCreate()</code> and start it with <code>f.ServerStart()</code>.</p> <pre><code>package main\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerStart(srv)\n}\n</code></pre> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerWithEmbeddedFileSystem(srv, dist)\n    f.ServerStart(srv)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>f.ServerWithHostname()</code> and <code>f.ServerWithPortNumber()</code>.</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerWithPort(srv, 8989)\n    f.ServerWithHostName(srv, \"192.168.0.123\")\n    f.ServerWithEmbeddedFileSystem(srv, dist)\n    f.ServerStart(srv)\n}\n</code></pre>"},{"location":"sessions/","title":"Sessions","text":"<p>Use <code>f.SessionStart()</code> to start a session.</p> <pre><code>f.ServerWithApi(srv, \"GET /\",\n    func(req *f.Request, res *f.Response) {\n        get, set, unset := f.SessionStart(req, res)\n    },\n)\n</code></pre> <p><code>f.SessionStart()</code> always succeeds and it always returns three functions, get, set and unset.</p> <p>Note</p> <p>The reason <code>f.SessionStart()</code> always succeeds is because it will automatically create a new session if none is found. The new session does not retain any data from the previous session.</p>"},{"location":"sessions/#get","title":"Get","text":"<p>Use <code>get()</code> to retrieve a session property.</p> <pre><code>get, _, _ := f.SessionStart(req, res)\nusername := get(\"username\", \"guest\").(string)\n</code></pre>"},{"location":"sessions/#set","title":"Set","text":"<p>Use <code>set()</code> to create or update a session property.</p> <pre><code>_, set, _ := f.SessionStart(req, res)\nset(\"username\", \"frizzante\")\n</code></pre>"},{"location":"sessions/#unset","title":"Unset","text":"<p>Use <code>unset()</code> to remove a session property.</p> <pre><code>_, _, unset := f.SessionStart(req, res)\nunset(\"username\")\n</code></pre>"},{"location":"sessions/#session-operator","title":"Session operator","text":"<p>You can overwrite the default in-memory session operator and provide  your own <code>get</code>, <code>set</code>, <code>unset</code>, <code>validate</code> and <code>destroy</code> functions.</p> <p>Use <code>f.ServerWithSessionOperator()</code> to overwrite the default session operator</p> <pre><code>f.ServerWithSessionOperator(srv, func(id string) (\n    get func(key string, defaultValue any) (value any),\n    set func(key string, value any),\n    unset func(key string),\n    validate func() bool,\n    destroy func(),\n) {\n    get = func(key string, defaultValue any) (value any) {\n        // ...\n    }\n\n    set = func(key string, value any) {\n        // ...\n    }\n\n    unset = func(key string) {\n        // ...\n    }\n\n    validate = func() {\n        // ...\n    }\n\n    destroy = func() {\n        // ...\n    }\n    return\n})\n</code></pre> <p>Note</p> <p><code>Validate</code> and <code>destroy</code> are used by the server internally  to manage and destroy sessions that are no longer valid.</p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>f.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p> <p>Instead, <code>f.ServerWithSessionOperator()</code> has complete control over the lifetime of any session.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to web sockets with <code>f.SendWebSocketUpgrade()</code>.</p> <pre><code>f.ServerWithApi(srv, \"GET /\",\n    func(_ *f.Server, req *f.Request, res *f.Response) {\n        f.SendWebSocketUpgrade(res, func() {\n            for {\n                f.SendEcho(res, \"hello\")\n                msg := f.ReceiveMessage(req)\n                fmt.Printf(\"Received message `%s`.\\n\", msg)\n            }\n        })\n    },\n)\n</code></pre> <p>Note</p> <p>Once the callback function returns,  for example by exiting the <code>for</code> loop,  the web socket connection ends.</p>"}]}