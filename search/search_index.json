{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Create a new project by cloning the starter template</p> Bash<pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; \\\nrm frizzante-starter/.git -fr\n</code></pre> <p>Then navigate to it</p> Bash<pre><code>cd frizzante-starter\n</code></pre> <p>Configure project</p> Bash<pre><code>make configure\n</code></pre> <p>Update dependencies</p> Bash<pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have Go, build-essential and Bun installed. If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Then you can start the server with</p> Bash<pre><code>make start\n</code></pre> <p>Enter development mode with</p> Bash<pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> Bash<pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>You can create apis with <code>f.ServerWithApiBuilder()</code></p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.ApiContext) {\n    // Build api.\n    withPattern, withHandler := context()\n    withPattern(\"GET /\")\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response) {\n    // Handle request.\n}\n</code></pre> <p>Where <code>withPattern()</code> routes the api using a pattern and <code>withHandler()</code> sets the request handler.</p> <p>Note</p> <p>You can route the same api to multiple patterns Go<pre><code>withPattern(\"GET /\")\nwithPattern(\"GET /api/greeting\")\nwithHandler(handle)\n</code></pre></p>"},{"location":"api/#echo","title":"Echo","text":"<p>You can send out text with <code>f.SendEcho()</code></p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    f.SendEcho(response, \"hello\")\n}\n</code></pre>"},{"location":"api/#path","title":"Path","text":"<p>You can define path fields in your pattern using the curly  braces format <code>{}</code> and retrieve fields with <code>f.ReceivePath()</code>.</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    name := f.ReceivePath(request, \"name\")\n    f.SendEcho(response, \"hello \"+name)\n}\n</code></pre>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>f.SendStatus()</code></p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    f.SendStatus(response, 404)\n    f.SendEcho(response, \"Resource not found, sorry.\")\n}\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header","title":"Header","text":"<p>You can retrieve header fields with <code>f.ReceiveHeader()</code> and send out header fields with <code>f.SendHeader()</code>.</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    contentType := f.ReceiveHeader(request, \"Content-Type\")\n    if \"application/xml\" != contentType {\n        f.SendStatus(response, 400)\n        f.SendHeader(response, \"Content-Length\", \"69\")\n        f.SendEcho(response, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n        return\n    }\n\n    f.SendStatus(response, 404)\n    f.SendHeader(response, \"Content-Length\", \"26\")\n    f.SendEcho(response, \"Resource not found, sorry.\")\n}\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>f.ReceiveQuery()</code></p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    name := f.ReceiveQuery(request, \"name\")\n    f.SendEcho(response, \"hello \"+name)\n}\n</code></pre>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>f.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    form := f.ReceiveForm(request)\n    name := form.Get(\"name\")\n    f.SendEcho(response, \"hello \"+name)\n}\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>f.ReceiveJson[T]()</code>.</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    person, _ := f.ReceiveJson[Person](request)\n    f.SendEcho(response, \"hello \"+person.name)\n}\n</code></pre> <p>Where <code>Person</code> would be a struct</p> Go<pre><code>type Person struct {\n    Name string\n}\n</code></pre>"},{"location":"api/#conventions","title":"Conventions","text":"<p>Api functions should be created under <code>lib/api/{name}.go</code>, where <code>{name}</code> is the name of the api.</p>"},{"location":"cancellation/","title":"Cancellation","text":"<p>Always track cancelled requests while streaming events, web sockets, executing long running tasks or expensive tasks in your request handlers.</p> <p>You can detect cancelled requests with <code>f.ReceiveCancellation()</code>.</p> <p>For example using sse</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.ApiContext) {\n    // Build api.\n    withPattern, withHandler := context()\n    withPath(\"/welcome\")\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response) {\n    // Get a pointer to the connection status.\n    alive := requestIsAlive(request)\n\n    // Upgrade to server sent events.\n    withEventName := f.SendSseUpgrade(response)\n    withEventName(\"server-time\")\n\n    // Continuously check if connection is still alive.\n    for *alive {\n        f.SendEcho(response, fmt.Sprintf(\"Server time is %s\", time.Now()))\n    }\n}\n\nfunc requestIsAlive(request *f.Request) *bool {\n    // Assuming the connection is alive when starting\n    // and initializing state.\n    value := true\n    go func() {\n        // Wait for cancellation.\n        &lt;-f.ReceiveCancellation(request)\n\n        // Update state after cancellation.\n        value = false\n    }()\n\n    // Return state pointer.\n    return &amp;value\n}\n</code></pre> <p>or using web sockets</p> Go<pre><code>func handle(request *f.Request, response *f.Response) {\n    // Get a pointer to the connection status.\n    alive := requestIsAlive(request)\n\n    // Upgrade to web sockets.\n    f.SendWsUpgrade(response)\n\n    // Continuously check if connection is still alive.\n    for *alive {\n        f.SendEcho(response, \"hello\")\n        msg := f.ReceiveMessage(request)\n        fmt.Printf(\"Received message `%s`.\\n\", msg)\n    }\n}\n</code></pre>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>f.ServerWithCertificateAndKey()</code>.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Setup certificate.\n    f.ServerWithCertificateAndKey(server, \"cert.pem\", \"key.pem\")\n\n    // Start.\n    f.ServerStart(server)\n}\n</code></pre> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"guards/","title":"Guards","text":"<p>Use <code>f.ServerWithGuardBuilder()</code> to add a new guard.</p> <p>Note</p> <p>A guard is a setup function that can inject arbitrary request handlers to handle incoming requests before they reach any of your api and page handlers. Guards can decide which requests should pass through and which request should be rejected.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Guards.\n    f.ServerWithGuardBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.GuardContext) {\n    // Build guard.\n    withHandler := context()\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response, pass func()) {\n    // Guard.\n    pass()\n}\n</code></pre> <p>Use <code>pass()</code> to let the current request pass through.</p> <p>Warning</p> <p>Failing to invoke <code>pass()</code> means the current request will be rejected.</p>"},{"location":"guards/#conventions","title":"Conventions","text":"<p>Guards should be created under <code>lib/guards/{name}.go</code>, where <code>{name}</code> is the name of the guard.</p>"},{"location":"make/","title":"Make","text":"<p>You can use <code>go run lib/make/main.go</code> to create apis, guards and pages from your terminal.</p>"},{"location":"make/#api","title":"Api","text":"<p>Use <code>go run lib/make/main.go -api -name=\"{name}\"</code> to create an api, where <code>{name}</code> is the human readable name of the api.</p> <p>Example</p> <p>Bash<pre><code>go run lib/make/main.go -api -name=\"login\"\n</code></pre> This will create a <code>lib/api/login.go</code> file.</p> <p>As an alternative, you can use the provided makefile command</p> Bash<pre><code>make api\n</code></pre>"},{"location":"make/#guards","title":"Guards","text":"<p>Use <code>go run lib/make/main.go -guard -name=\"{name}\"</code> to create a guard, where <code>{name}</code> is the human readable name of the guard.</p> <p>Example</p> <p>Bash<pre><code>go run lib/make/main.go -guard -name=\"session\"\n</code></pre> This will create a <code>lib/guards/session.go</code> file.</p> <p>As an alternative, you can use the provided makefile command</p> Bash<pre><code>make guard\n</code></pre>"},{"location":"make/#pages","title":"Pages","text":"<p>Use <code>go run lib/make/main.go -page -name=\"{name}\"</code> to create a page, where <code>{name}</code> is the human readable name of the page.</p> <p>Example</p> <p>Bash<pre><code>go run lib/make/main.go -page -name=\"welcome\"\n</code></pre> This will create files <code>lib/page/welcome.go</code> and <code>lib/components/views/Welcome.svelte</code>.</p> <p>As an alternative, you can use the provided makefile command</p> Bash<pre><code>make page\n</code></pre>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> XML<pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a JavaScript bundle, which once loaded, takes over the Dom.</p> <p>Although more powerful and versatile, this mode adds some complexity to your application.</p>"},{"location":"pages/","title":"Pages","text":"<p>Before creating a page, you need to create a view.</p> <p>Note</p> <p>See the views section for more details.</p> <p>Views can be referred to by your Go code using their name relative to <code>lib/components/views</code>.</p> <p>Example</p> <p>A view located at <code>lib/components/views/Welcome.svelte</code> will be identified by <code>Welcome</code>.</p> <p>Subdirectories are joined by <code>.</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A view located at <code>lib/components/views/about/Me.svelte</code> will be identified by <code>about.Me</code>.</p> <p>After you've created your view, you can create a page with <code>f.ServerWithPageBuilder()</code></p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Pages.\n    f.ServerWithPageBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\n\nfunc build(context f.PageContext) {\n    // Build page.\n    withPath, withView, withBase, withAction := context()\n    withPath(\"/welcome\")\n    withView(f.ViewReference(\"Welcome\")) // This references the file \n                                         // \"lib/components/views/Welcome.svelte\"\n    withBase(base)\n    withAction(action)  \n}\n\nfunc base(request *f.Request, response *f.Response, view *f.View) {\n    // Show page.\n}\n\nfunc action(request *f.Request, response *f.Response, view *f.View) {\n    // Modify state.\n}\n</code></pre> <p>In your setup function, <code>withPath()</code> sets the path of your page  and <code>withView()</code> sets the view of your page.</p> <p>Note</p> <p>You can map many paths to one view. Go<pre><code>withPath(\"/\")\nwithPath(\"/api/greeting\")\nwithView(f.ViewReference(\"Welcome\"))\n</code></pre></p> <p>Danger</p> <p>You cannot map many views to one path. Go<pre><code>withPath(\"/\")\nwithView(f.ViewReference(\"Welcome\"))  // &lt;-- This is not allowed,\nwithView(f.ViewReference(\"Login\"))    // &lt;-- two views are exposed by the same path.\n</code></pre></p> <p><code>withBaseHandler()</code> sets the page base handler</p> <p>Note</p> <p>A base page handler is a function that  handles requests to the <code>GET</code> http verb. This function usually does not modify the state,  it just renders information to the screen.</p> <p><code>withActionHandler()</code> sets the page action handler</p> <p>Note</p> <p>An action page handler is a function that  handles requests to the <code>POST</code> http verb. This function usually modifies the state and  sometimes redirects to some other page.</p> <p>While handling the page, you can inject data into the view with <code>f.ViewWithData()</code></p> Go<pre><code>func base(request *f.Request, response *f.Response, view *f.View) {\n    f.ViewWithData(view, \"name\", \"world\")\n}\n</code></pre> <p>Note</p> <p>These data fields can be retrieved from your svelte components with getContext(\"data\").</p> HTML<pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>Context <code>data</code> is created with $state(), hence it is reactive.</p> <p>Note</p> <p>A page is treated like an api under the hood, which means it  has access to the same features.  You can receives path fields with <code>f.ReceivePath()</code>,  queries with <code>f.ReceiveQuery()</code>, forms with <code>f.ReceiveForm()</code>, json objects with <code>f.ReceiveJson[T]()</code> and so on.</p> <p>Danger</p> <p>While rendering a page, you shouldn't send content to the client directly  using <code>f.Send*</code> functions,  like <code>f.SendEcho()</code>, <code>f.SendJson()</code>.  Sending content directly to the client will break the HTML document structure by prepending  the content to the actual view.  There are some use cases where sending content directly is useful, like debugging.</p> <p>Note</p> <p>Functions that send the status and header fields, like <code>f.SendStatus()</code>, <code>f.SendHeader()</code>, are safe to use.</p>"},{"location":"pages/#other-details","title":"Other details","text":"<p>Page functions should be created under <code>lib/pages/{name}.go</code>, where <code>{name}</code> is the name of the page.</p>"},{"location":"server-sent-events/","title":"Server sent events","text":"<p>You can upgrade http requests to server sent events with <code>f.SendSseUpgrade()</code>.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.ApiContext) {\n    // Build api.\n    withPath, withHandler := context()\n    withPath(\"/welcome\")\n    withView(f.ViewReference(\"Welcome\")) // This references the file \n                                         // \"lib/components/views/Welcome.svelte\"\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response) {\n    // Upgrade to server sent events.\n    withEventName := f.SendSseUpgrade(response)\n\n    for {\n        // Send to channel-1.\n        withEventName(\"channel-1\")\n        f.SendEcho(response, \"This is a message for channel-1\")\n\n        // Send to channel-2.\n        withEventName(\"channel-2\")\n        f.SendEcho(response, \"This is a message for channel-2\")\n        f.SendEcho(response, \"This is another message for channel-2\")\n\n        // Send to channel-1.\n        withEventName(\"channel-1\")\n        f.SendEcho(response, \"Back to channel-1\")\n\n        // Sleep for a bit.\n        time.Sleep(time.Second)\n    }\n}\n</code></pre> <p>Set the name of the current event with <code>withEventName</code>,  then start sending content to the client with the usual <code>f.SendEcho()</code> and <code>f.SendJson()</code>.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the event stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming events. Read more about cancellation here.</p> <p>Note</p> <p>The default event name is <code>message</code>.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>f.ServerCreate()</code> and start it with <code>f.ServerStart()</code>.</p> Go<pre><code>package main\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerStart(server)\n}\n</code></pre> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerStart(server)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>f.ServerWithHostname()</code> and <code>f.ServerWithPortNumber()</code>.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    server := f.ServerCreate()\n    f.ServerWithPort(server, 8989)\n    f.ServerWithHostName(server, \"192.168.0.123\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerStart(server)\n}\n</code></pre>"},{"location":"sessions/","title":"Sessions","text":"<p>Use <code>f.SessionStart()</code> to start a session.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.ApiContext){\n    // Build api.\n    withPath, withHandler := context()\n    withPath(\"/welcome\")\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response) {\n    // Start session.\n    _, _, _ := f.SessionStart(request, response)\n}\n</code></pre> <p><code>f.SessionStart()</code> always succeeds and it always returns three functions, get, set and unset.</p> <p>Note</p> <p>The reason <code>f.SessionStart()</code> always succeeds is because it will automatically create a new session if none is found. The new session does not retain any data from the previous session.</p>"},{"location":"sessions/#get","title":"Get","text":"<p>Use <code>get()</code> to retrieve a session property.</p> Go<pre><code>get, _, _ := f.SessionStart(request, response)\nusername := get(\"username\", \"default\").(string)\n</code></pre>"},{"location":"sessions/#set","title":"Set","text":"<p>Use <code>set()</code> to create or update a session property.</p> Go<pre><code>_, set, _ := f.SessionStart(request, response)\nset(\"username\", \"frizzante\")\n</code></pre>"},{"location":"sessions/#unset","title":"Unset","text":"<p>Use <code>unset()</code> to remove a session property.</p> Go<pre><code>_, _, unset := f.SessionStart(request, response)\nunset(\"username\")\n</code></pre>"},{"location":"sessions/#session-operator","title":"Session operator","text":"<p>You can overwrite the default in-memory session operator and provide  your own <code>get</code>, <code>set</code>, <code>unset</code>, <code>validate</code> and <code>destroy</code> functions.</p> <p>Use <code>f.ServerWithSessionBuilder()</code> to overwrite the default session operator</p> Go<pre><code>f.ServerWithSessionBuilder(server, func(context SessionContext) {\n    sessionId, \n    withGetter, \n    withSetter,\n    withUnsetter, \n    withValidator, \n    withDestroyer := context()\n\n    withGetter(func(key string, defaultValue any) (value any) {\n        // Get `key` from the session store.\n        // If `key` doesn't exist, create it with value `defaultValue`.\n    })\n\n    withSetter(func(key string, value any) {\n        // Set `key` to the session store.\n    })\n\n    withUnsetter(func(key string) {\n        // Unset `key` from the session store.\n    })\n\n    withValidator(func() (valid bool) {\n        // Validate `sessionId`.\n    })\n\n    withDestroyer(func() {\n        // Destroy the session `sessionId` and its store.\n    })\n})\n</code></pre> <p>Note</p> <p>The <code>withValidator()</code> function is used by Frizzante to validate sessions whenever you invoke <code>f.SessionStart()</code>.  The <code>withDestroyer()</code> function is used by Frizzante to destroy a sessions whenever validation fails.</p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>f.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p> <p>Instead, <code>f.ServerWithSessionBuilder()</code> has complete control over the lifetime of any session.</p>"},{"location":"views/","title":"Views","text":"<p>Views are <code>.svelte</code> components located under <code>lib/components/views</code>.</p> <p>Here's an example of a view located under <code>lib/components/views/Welcome.svelte</code></p> HTML<pre><code>&lt;script&gt;\n    let name = \"world\"\n&lt;/script&gt;\n\nHello {name}!\n</code></pre> <p>Note</p> <p>Views are used by Go pages to render content. See the pages section for more details.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to web sockets with <code>f.SendWsUpgrade()</code>.</p> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.ServerCreate()\n    notifier := f.NotifierCreate()\n\n    // Setup.\n    f.ServerWithPort(server, 8080)\n    f.ServerWithHostName(server, \"127.0.0.1\")\n    f.ServerWithEmbeddedFileSystem(server, dist)\n    f.ServerWithNotifier(server, notifier)\n\n    // Api.\n    f.ServerWithApiBuilder(server, build)\n\n    // Start.\n    f.ServerStart(server)\n}\n\nfunc build(context f.ApiContext){\n    withPath, withHandler := context()\n    // Build api.\n    withPath(\"/welcome\")\n    withHandler(handle)\n}\n\nfunc handle(request *f.Request, response *f.Response) {\n    f.SendWsUpgrade(response)\n\n    for {\n        // Send message.\n        f.SendEcho(response, \"hello\")\n\n        // Wait for incoming message.\n        msg := f.ReceiveMessage(request)\n\n        // Log.\n        fmt.Printf(\"Received message `%s`.\\n\", msg)\n    }\n}\n</code></pre> <p>Use the usual <code>f.SendEcho()</code> to send a raw text message and <code>f.SendJson()</code> to send a json message to the client.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the web socket stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming web sockets. Read more about cancellation here.</p>"}]}