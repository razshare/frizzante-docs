{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"#server-mode","title":"Server mode","text":"<p>This mode is how the web was intended to work as a whole.</p> <p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will truly be a traditional web site, loading documents from scratch with each interaction you engage with the server.</p> <p>Not only that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of your interactivity will have to come through either forms or or Css.</p> <p>I say <code>most</code> because you can still inject external JavaScripts through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> <pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"#client-mode","title":"Client mode","text":"<p>This is how you basically build SPAs.</p> <p>Your whole application consists in 1 JavaScript file, 1 Css file and 1 Html file, that's it.</p> <p>In this mode, building interactive experiences is easier than in server mode.</p> <p>Since the server simply renders a generic html document before the actual application loads, in this mode, search engines have a harder time indexing you web site.</p>"},{"location":"#full-mode","title":"Full mode","text":"<p>It's just as it sounds, the the server both fully renders an html document and also serves a javaScript bundle, which once loaded, takes of the Dom.</p>"},{"location":"get-started/","title":"Get started","text":"<p>Make sure you have Go and Bun installed.</p> <p>Note</p> <p>If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Create a new project using the starter template.</p> <pre><code>git clone https://github.com/razshare/frizzante-starter\n</code></pre> <p>Update your dependencies </p> <pre><code>make update\n</code></pre> <p>Then you can start the server with</p> <pre><code>make start\n</code></pre> <p>You can enter dev mode with</p> <pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> <pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>out/app</code> file.</p>"},{"location":"prepare/","title":"Prepare","text":"<p>Whenever you start the server, enter dev mode or build your program, a make file task called <code>www-prepare</code> is executed.</p> <p>This task is necessary, as it prepares all files needed for the project to function properly.</p> <p>This \"preparation\" phase is handled by the <code>prepare/main.go</code> program, which usually looks like this</p> <pre><code>package main\n\nimport frz \"github.com/razshare/frizzante\"\n\nfunc main() {\n    frz.SveltePrepareStart()\n    frz.SveltePreparePage(\"welcome\", \"./www/lib/pages/welcome.svelte\")\n    frz.SveltePrepareEnd()\n}\n</code></pre> <p>Unlike other solutions, there is no special syntax or naming convention that marks your files as \"pages\", instead you define your pages in this preparation phase by invoking</p> <pre><code>frz.SveltePreparePage(\"page-id\", \"./path/to/my/component.svelte\")\n</code></pre> <p>Once you've done so, the <code>./path/to/my/component.svelte</code> will be considered a page and you will refer to this page as <code>page-id</code> throughout the rest of your code.</p> <p>Note</p> <p>Obviously <code>page-id</code> and <code>./path/to/my/component.svelte</code> are placeholder names.</p> <p>Warning</p> <p>The path to the svelte file is relative your cwd, not to the <code>prepare/</code> directory!</p> <p>Note</p> <p>In the future, there will be available more types of preparation methods that generate code for your, like automatic type hints conversion from Go structs to Js types. That's the most obvious one.</p>"},{"location":"request-handlers/","title":"Request handlers","text":"<p>You can listen for requests with <code>frz.ServerWithRequestHandler()</code>.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        frz.SendEcho(response, \"hello\")\n    },\n)\n</code></pre> <p>This code will listen for requests on <code>GET /</code> and send the <code>hello</code> in response.</p>"},{"location":"request-handlers/#status","title":"Status","text":"<p>You can send out a status code with <code>frz.SendStatus()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        frz.SendStatus(response, 404)\n        frz.SendEcho(response, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields. Failing to do so will result in a server error.</p>"},{"location":"request-handlers/#headers","title":"Headers","text":"<p>You can retrieve header fields with <code>frz.ReceiveHeader()</code> and send out header fields wit <code>frz.SendHeader()</code>.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        contentType := frz.ReceiveHeader(request, \"Content-Type\")\n        if \"application/xml\" != contentType {\n            frz.SendStatus(response, 400)\n            frz.SendHeader(response, \"Content-Length\", \"69\")\n            frz.SendEcho(response, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n            return\n        }\n\n        frz.SendStatus(response, 404)\n        frz.SendHeader(response, \"Content-Length\", \"26\")\n        frz.SendEcho(response, \"Resource not found, sorry.\")\n    },\n)\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body. Failing to do so will result in a server error.</p>"},{"location":"request-handlers/#parameters","title":"Parameters","text":"<p>You can define parameters in your path via the <code>{parameter}</code> syntax, the name of the parameter wrapped in curly braces.</p> <p>You can then retrieve the value of the parameter with <code>frz.ReceiveParameter()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /about/{name}\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        name := frz.ReceiveParameter(request, \"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre>"},{"location":"request-handlers/#query","title":"Query","text":"<p>Similarly, you can retrieve values of query fields with <code>frz.ReceiveQuery()</code></p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"GET /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        name := frz.ReceiveQuery(request, \"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre>"},{"location":"request-handlers/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>frz.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <pre><code>frz.ServerWithRequestHandler(\n    server,\n    \"POST /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        form := frz.ReceiveForm(request)\n        name := form.Get(\"name\")\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, name)\n    },\n)\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail reading the form.</p>"},{"location":"request-handlers/#json","title":"Json","text":"<p>Json bodies can be easily read and decoded with <code>frz.ReceiveJson()</code>.</p> <p>This method is a bit different that the others because it doesn't return a value, instead it takes in an objects and projects the contents of the json onto said object.</p> <pre><code>type Person struct {\n    Name string `json:\"name\"`\n}\n\nfrz.ServerWithRequestHandler(\n    server,\n    \"POST /about\", \n    func(server *frz.Server, request *frz.Request, response *frz.Response) {\n        person := &amp;Person{}\n        form := frz.ReceiveJson(request, person)\n        frz.SendEcho(response, \"hello \")\n        frz.SendEcho(response, person.Name)\n    },\n)\n</code></pre>"},{"location":"server/","title":"Server","text":"<p>Create a server with <code>frz.CreateServer()</code>  and starting it with <code>frz.ServerStart()</code>.</p> <pre><code>import frz \"github.com/razshare/frizzante\"\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerStart(server)\n}\n</code></pre> <p>However, this is not any type of server, we want to bundle our resources into the final executable.</p> <p>For that reason you'll need to create an embedded file system with <code>go:embed</code>, include the <code>www/dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <pre><code>import \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed www/dist/*/**\nvar efs embed.FS\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerWithEmbeddedFileSystem(server, efs)\n    frz.ServerStart(server)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>frz.ServerWithHostname()</code> and <code>frz.ServerWithPortNumber()</code>.</p> <pre><code>import \"embed\"\nimport frz \"github.com/razshare/frizzante\"\n\n//go:embed www/dist/*/**\nvar efs embed.FS\n\nfunc main() {\n    server := frz.ServerCreate()\n    frz.ServerWithPort(server, 8989)\n    frz.ServerWithHostName(server, \"192.168.0.123\")\n    frz.ServerWithEmbeddedFileSystem(server, efs)\n    frz.ServerStart(server)\n}\n</code></pre>"},{"location":"svelte-pages/","title":"Svelte pages","text":"<p>As previously mentioned in the prepare section, pages are defined beforehand in the prepare phase.</p> <p>However, defining a page doesn't mean it's being routed.</p> <p>You must route pages yourself through the server api.</p> <p>You can route a page with <code>frz.ServerWithSveltePage()</code>.</p> <pre><code>frz.ServerWithSveltePage(server, \"GET /welcome\", \"welcome\", configure)\n</code></pre> <p>As you can see, routing a page requires a pattern (<code>GET /welcome</code>), the id of the page (<code>welcome</code>) and a <code>configure</code> function, which look like this</p> <pre><code>func configure(_ *frz.Request) *frz.SveltePageConfiguration {\n    return &amp;frz.SveltePageConfiguration{\n        Render: frz.ModeFull,\n        Props: map[string]interface{}{\n            \"name\": \"world\",\n        },\n    }\n}\n</code></pre> <p>The <code>Render</code> property is the rendering mode, which can be <code>frz.ModeServer</code>, <code>frz.ModeClient</code> or <code>frz.ModeFull</code>.</p> <p>The <code>Props</code> property are the properties of the page.</p>"}]}