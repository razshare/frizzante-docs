{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Create a new project by cloning the starter template</p> Bash<pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; \\\nrm frizzante-starter/.git -fr\n</code></pre> <p>Then navigate to it</p> Bash<pre><code>cd frizzante-starter\n</code></pre> <p>Configure project</p> Bash<pre><code>make configure\n</code></pre> <p>Update dependencies</p> Bash<pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have Go, build-essential and Bun installed. If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Then you can start the server with</p> Bash<pre><code>make start\n</code></pre> <p>Enter development mode with</p> Bash<pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> Bash<pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>Use <code>server.OnRequest()</code> to handle incoming requests.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.OnRequest(\"GET /api\", func(req *f.Request, res *f.Response){\n        // Handle request.\n    })\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p>Use <code>server.WithApiController()</code> to handle requests in a more opinionated way, using a controller</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p>where <code>api.MyApiController</code> is defined as</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>package api\n\nimport (\n    \"fmt\"\n    f \"github.com/razshare/frizzante\"\n)\n\ntype MyApiController struct {\n    f.ApiController\n}\n\nfunc (_ MyApiController) Configure() f.ApiConfiguration {\n    return f.ApiConfiguration{\n        Pattern: \"GET /api/my-controller\",\n    }\n}\n\nfunc (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Handle request.\n}\n</code></pre></p>"},{"location":"api/#send-message","title":"Send message","text":"<p>You can send out a message with <code>res.SendMessage()</code></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    res.SendMessage(\"hello\")\n}\n</code></pre></p>"},{"location":"api/#path","title":"Path","text":"<p>You can define path fields in your pattern using the curly  braces format <code>{}</code> and retrieve fields with <code>res.ReceivePath()</code>.</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    name := req.ReceivePath(\"name\")\n    res.SendMessage(\"hello \"+name)\n}\n</code></pre></p>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>res.SendStatus()</code></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    res.SendStatus(404)\n    res.SendMessage(\"Resource not found, sorry.\")\n}\n</code></pre></p> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header","title":"Header","text":"<p>You can retrieve header fields with <code>req.ReceiveHeader()</code> and send out header fields with <code>res.SendHeader()</code>.</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    contentType := req.ReceiveHeader(\"Content-Type\")\n    if \"application/xml\" != contentType {\n        res.SendStatus(400)\n        res.SendHeader(\"Content-Length\", \"69\")\n        res.SendMessage(\"We don't serve your kind around here, better get an XML encoder, heh.\")\n        return\n    }\n\n    res.SendStatus(404)\n    res.SendHeader(\"Content-Length\", \"26\")\n    res.SendMessage(\"Resource not found, sorry.\")\n}\n</code></pre></p> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>req.ReceiveQuery()</code></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    name := req.ReceiveQuery(\"name\")\n    res.SendMessage(\"hello \"+name)\n}\n</code></pre></p>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>req.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    form := req.ReceiveForm()\n    name := form.Get(\"name\")\n    res.SendMessage(\"hello \"+name)\n}\n</code></pre></p> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>req.ReceiveJson[T]()</code>.</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    var person Person\n    req.ReceiveJson(person)\n    res.SendMessage(\"hello \"+person.Name)\n}\n</code></pre></p> <p>Where <code>Person</code> would be a struct</p> Go<pre><code>type Person struct {\n    Name string\n}\n</code></pre>"},{"location":"api/#conventions","title":"Conventions","text":"<p>Api functions should be created under <code>lib/controllers/api/{name}.go</code>, where <code>{name}</code> is the name of the api.</p>"},{"location":"cancellation/","title":"Cancellation","text":"<p>Always track cancelled requests while streaming events, web sockets, executing long running tasks or expensive tasks in your request handlers.</p> <p>You can detect cancelled requests with <code>req.IsAlive()</code>.</p> <p>For example using sse</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>func (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Track the status of the request.\n    alive := req.IsAlive()\n\n    // Upgrade to server sent events.\n    event := res.SendSseUpgrade()\n    event(\"server-time\")\n\n    // Loop until request is cancelled.\n    for *alive {\n        now := time.Now()\n        message := fmt.Sprintf(\"Server time is %s\", now)\n        res.SendMessage(message)\n    }\n}\n</code></pre></p>"},{"location":"certificates/","title":"Certificates","text":"<p>Assign a certificate to the server with <code>server.WithCertificate()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Setup certificate.\n    server.WithCertificate(\"cert.pem\", \"key.pem\")\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"cli/","title":"Cli","text":"<p>You can use <code>go run lib/cli/main.go</code> to create apis and pages from your terminal.</p>"},{"location":"cli/#api","title":"Api","text":"<p>Use <code>go run lib/cli/main.go -api -name=\"{name}\"</code> to create an api, where <code>{name}</code> is the human readable name of the api.</p> <p>Example</p> <p>Bash<pre><code>go run lib/cli/main.go -api -name=\"login\"\n</code></pre> This will create a <code>lib/api/Login.go</code> file.</p>"},{"location":"cli/#pages","title":"Pages","text":"<p>Use <code>go run lib/cli/main.go -page -name=\"{name}\"</code> to create a page, where <code>{name}</code> is the human readable name of the page.</p> <p>Example</p> <p>Bash<pre><code>go run lib/cli/main.go -page -name=\"welcome\"\n</code></pre> This will create files <code>lib/page/Welcome.go</code> and <code>lib/components/views/Welcome.svelte</code>.</p>"},{"location":"guards/","title":"Guards","text":"<p>You can guard api and page controllers by configuring the <code>Guards</code> property on your controller.</p> <p>First you need to expose your controller</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p>then within your controller configure the <code>Guards</code> property.</p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>package api\n\nimport (\n    \"fmt\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/guards\"\n    \"time\"\n)\n\ntype MyApiController struct {\n    f.ApiController\n}\n\nfunc (_ MyApiController) Configure() f.ApiConfiguration {\n    return f.ApiConfiguration{\n        Pattern: \"GET /api/my-controller\",\n        // Configure guards here.\n        Guards: []f.GuardFunction{\n            guards.SessionIsValid,\n        }\n    }\n}\n\nfunc (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Handle request.\n}\n</code></pre></p> <p>Where <code>guards.SessionIsValid</code> is a guard function.</p> <p>Note</p> <p>A guard function is a function that handles incoming requests before they reach any of your actual api and page handlers. Guards can decide which requests should pass through and which request should be rejected.</p> <p><code>lib/guards/SessionIsValid.go</code> Go<pre><code>package guards\n\nimport (\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/sessions\"\n    \"time\"\n)\n\nfunc SessionIsValid(req *f.Request, res *f.Response) bool {\n    session := f.SessionStart(req, res, sessions.Archived)\n\n    if time.Since(session.Data.LastActivity) &gt; 30*time.Minute {\n        session.Destroy()\n        res.SendNavigate(\"Expired\")\n        return false\n    }\n\n    session.Data.LastActivity = time.Now()\n    return true\n}\n</code></pre></p> <p>Return <code>true</code> to let the request through and <code>false</code> to reject it.</p>"},{"location":"guards/#conventions","title":"Conventions","text":"<p>Guards should be created under <code>lib/guards/{name}.go</code>, where <code>{name}</code> is the name of the guard.</p>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> XML<pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a JavaScript bundle, which once loaded, takes over the Dom.</p> <p>Although more powerful and versatile, this mode adds some complexity to your application.</p>"},{"location":"pages/","title":"Pages","text":"<p>Use <code>server.WithPageController()</code> to create a page</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/pages\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Pages.\n    server.WithPageController(pages.MyPageController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p>where <code>pages.MyPageController</code> is defined as</p> <p><code>lib/controllers/page/MyPageController.go</code> Go<pre><code>package pages\n\nimport (\n    f \"github.com/razshare/frizzante\"\n)\n\ntype MyPageController struct {\n    f.PageController\n}\n\nfunc (_ MyPageController) Configure() f.PageConfiguration {\n    return f.PageConfiguration{\n        Path: \"/\",\n    }\n}\n\nfunc (_ MyPageController) Base(req *f.Request, res *f.Response) {\n    res.SendView(f.NewView(f.RenderFull))\n}\n\nfunc (_ MyPageController) Action(req *f.Request, res *f.Response) {\n    res.SendView(f.NewView(f.RenderFull))\n}\n</code></pre></p> <p>This controller expects a view located at <code>lib/components/views/MyPageView.svelte</code></p> <p>Note</p> <p>Page views are automatically bound to page controllers based on the name their names.  Any page controller is expected to be named as <code>{Name}Controller</code> and its view is expected to be named <code>{Name}View</code>, where <code>Name</code> is the common prefix binding the controller to the view.</p> <p>Example</p> <p>A page controller located at <code>lib/controllers/pages/TestController.go</code>  will bind to a page view located at <code>lib/components/views/TestView.svelte</code>.</p> <p><code>lib/components/views/MyPageView.svelte</code> HTML<pre><code>&lt;h1&gt;Welcome to Frizzante.&lt;/h1&gt;\n</code></pre></p> <p>Both <code>Base</code> and <code>Action</code> handlers must use <code>res.SendView()</code> to send the view to the client.</p> <p>Note</p> <p>A base page handler is a function that  handles requests to the <code>GET</code> http verb. This function usually does not modify the state,  it just renders information to the screen.</p> <p>Note</p> <p>An action page handler is a function that  handles requests to the <code>POST</code> http verb. This function usually modifies the state and  sometimes redirects to some other page.</p>"},{"location":"pages/#view","title":"View","text":"<p>Inject data into views with <code>f.NewViewWithData()</code></p> <p><code>lib/controllers/page/MyPageController.go</code> Go<pre><code>func (_ MyPageController) Base(req *f.Request, res *f.Response) {\n    data := map[string]string{\n        \"name\": \"world\",\n    }\n    res.SendView(f.NewViewWithData(f.RenderFull, data))\n}\n</code></pre></p> <p>This data can be retrieved from your svelte components using getContext(\"server\").</p> <p><code>lib/components/views/MyPageView.svelte</code> HTML<pre><code>&lt;script lang=\"ts\"&gt;\n    import {getContext} from \"svelte\";\n    import type {ServerContext} from \"$frizzante/types.ts\";\n\n    const server = getContext(\"server\") as ServerContext&lt;{ \n        name: string\n    }&gt;\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {server.data.name}!&lt;/h1&gt;\n</code></pre></p>"},{"location":"pages/#conventions","title":"Conventions","text":"<p>Page controllers should be created under <code>lib/controllers/pages/{name}Controller.go</code>, where <code>{name}</code> is the name of the page.</p> <p>Page views should be created under <code>lib/components/views/{name}Views.go</code>, where <code>{name}</code> is the name of the page.</p>"},{"location":"server-sent-events/","title":"Server sent events","text":"<p>You can upgrade http requests to server sent events with <code>res.SendSseUpgrade()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>package api\n\nimport (\n    \"fmt\"\n    f \"github.com/razshare/frizzante\"\n    \"time\"\n)\n\ntype MyApiController struct {\n    f.ApiController\n}\n\nfunc (_ MyApiController) Configure() f.ApiConfiguration {\n    return f.ApiConfiguration{\n        Pattern: \"GET /api/my-controller\",\n    }\n}\n\nfunc (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Upgrade to server sent events.\n    event := res.SendSseUpgrade()\n\n    for {\n        // Send to channel-1.\n        event(\"channel-1\")\n        res.SendMessage(\"This is a message for channel-1\")\n\n        // Send to channel-2.\n        event(\"channel-2\")\n        res.SendMessage(\"This is a message for channel-2\")\n        res.SendMessage(\"This is another message for channel-2\")\n\n        // Send to channel-1.\n        event(\"channel-1\")\n        res.SendMessage(\"Back to channel-1\")\n\n        // Sleep for a bit.\n        time.Sleep(time.Second)\n    }\n}\n</code></pre></p> <p>Set the name of the current event with <code>event()</code>,  then start sending content to the client with the usual <code>res.SendMessage()</code> and <code>res.SendJson()</code>.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the event stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming events. Read more about cancellation here.</p> <p>Note</p> <p>The default event name is <code>message</code>.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>f.NewServer()</code> and start it with <code>server.Start()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc main() {\n    server := f.NewServer()\n    server.Start()\n}\n</code></pre></p> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    server := f.NewServer()\n    server.WithEmbeddedFileSystem(&amp;dist)\n    server.Start()\n}\n</code></pre></p> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>server.WithEmbeddedFileSystem()</code> and <code>server.WithPortNumber()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n\n    server := f.NewServer()\n    server.WithHostname(\"192.168.0.123\")\n    server.WithPort(8989)\n    server.WithEmbeddedFileSystem(&amp;dist)\n    server.Start()\n}\n</code></pre></p>"},{"location":"sessions/","title":"Sessions","text":"<p>Before starting a session you first need a session builder.</p> <p>Note</p> <p>A session builder is a function that builds (or retrieves) a session's state. It provides the basic mechanisms for checking, getting, setting properties and a destroyer function, which specifies what should happen when a session is \"destroyed\".</p> <p><code>lib/sessions/memory.go</code> Go<pre><code>package sessions\n\nimport f \"github.com/razshare/frizzante\"\n\ntype State struct {\n    Name string `json:\"name\"`\n}\n\nvar memory = map[string]State{}\n\n// Memorized builds sessions in memory.\nfunc Memorized(session *f.Session[State]) {\n    session.WithExistsHandler(func() bool {\n        _, exists := memory[session.Id]\n        return exists\n    })\n\n    session.WithLoadHandler(func() {\n        session.Data = memory[session.Id]\n    })\n\n    session.WithSaveHandler(func() {\n        memory[session.Id] = session.Data\n    })\n\n    session.WithDestroyHandler(func() {\n        delete(memory, session.Id)\n    })\n\n    if session.Exists() {\n        session.Load()\n        return\n    }\n\n    session.Data = State{Name: \"world\"}\n}\n</code></pre></p>"},{"location":"sessions/#start-session","title":"Start session","text":"<p>Use <code>f.SessionStart()</code> to start the session.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>package api\n\nimport (\n    \"fmt\"\n    f \"github.com/razshare/frizzante\"\n)\n\ntype MyApiController struct {\n    f.ApiController\n}\n\nfunc (_ MyApiController) Configure() f.ApiConfiguration {\n    return f.ApiConfiguration{\n        Pattern: \"GET /api/my-controller\",\n    }\n}\n\nfunc (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Start session.\n    session := f.SessionStart(req, res, sessions.Memorized)\n}\n</code></pre></p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>f.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p>"},{"location":"views/","title":"Views","text":"<p>Views are <code>.svelte</code> files located under <code>lib/components/views</code>.</p> <p>Here's an example</p> <p><code>lib/components/views/WelcomeView.svelte</code> HTML<pre><code>&lt;script&gt;\n    let name = \"world\"\n&lt;/script&gt;\n\nHello {name}!\n</code></pre></p> <p>Note</p> <p>Views are automatically bound to Go page controllers to render content. See the pages section for more details.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to server sent events with <code>res.SendWsUpgrade()</code>.</p> <p><code>main.go</code> Go<pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n    \"main/lib/controllers/api\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    // Create.\n    server := f.NewServer()\n    notifier := f.NewNotifier()\n\n    // Configure.\n    server.WithPort(8080)\n    server.WithNotifier(notifier)\n    server.WithHostName(\"127.0.0.1\")\n    server.WithEmbeddedFileSystem(&amp;dist)\n\n    // Api.\n    server.WithApiController(api.MyApiController{})\n\n    //Start.\n    server.Start()\n}\n</code></pre></p> <p><code>lib/controllers/api/MyApiController.go</code> Go<pre><code>package api\n\nimport (\n    \"fmt\"\n    f \"github.com/razshare/frizzante\"\n    \"time\"\n)\n\ntype MyApiController struct {\n    f.ApiController\n}\n\nfunc (_ MyApiController) Configure() f.ApiConfiguration {\n    return f.ApiConfiguration{\n        Pattern: \"GET /api/my-controller\",\n    }\n}\n\nfunc (_ MyApiController) Handle(req *f.Request, res *f.Response) {\n    // Upgrade to web sockets.\n    res.SendWsUpgrade()\n\n    for {\n        // Send message.\n        res.SendMessage(\"hello\")\n\n        // Wait for incoming message.\n        msg := req.ReceiveMessage()\n\n        // Log.\n        fmt.Printf(\"RequestReceived message `%s`.\\n\", msg)\n    }\n}\n</code></pre></p> <p>You can send content to the client with the usual <code>res.SendMessage()</code> and <code>res.SendJson()</code>.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the web socket connection ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming web sockets. Read more about cancellation here.</p>"}]}