{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Get started","text":"<p>Make sure you have Go and Bun installed.</p> <p>Note</p> <p>If you'd rather use a different runtime than Bun to update your javascript dependencies, see makefile and change all occurrences of <code>bun</code> and <code>bunx</code> with the equivalent of whatever runtime you'd like to use.</p> <p>Create a new project using the starter template.</p> <pre><code>git clone https://github.com/razshare/frizzante-starter &amp;&amp; cd frizzante-starter &amp;&amp; rm .git -fr\n</code></pre> <p>Update dependencies</p> <pre><code>make update\n</code></pre> <p>Note</p> <p>Make sure you have build-essential installed <pre><code>sudo apt install build-essential\n</code></pre></p> <p>Then you can start the server with</p> <pre><code>make start\n</code></pre> <p>You can enter dev mode with</p> <pre><code>make dev\n</code></pre> <p>Or you can build the whole project with</p> <pre><code>make build\n</code></pre> <p>This will create a single, standalone, executable <code>bin/app</code> file.</p>"},{"location":"api/","title":"Api","text":"<p>You can route apis with <code>f.ServerWithApi()</code></p> <pre><code>f.ServerWithApi(srv, api)\n</code></pre> <p>Where <code>api</code> is a setup function</p> <pre><code>func api(\n    withPattern func(pattern string),\n    withHandler func(handler func(req *f.Request, res *f.Response)),\n) {\n    withPattern(\"GET /\")\n    withHandler(handler)\n}\n\nfunc handler(req *f.Request, res *f.Response) {\n    // Handle request.\n}\n</code></pre> <p>Use <code>withPattern()</code> to route the api using a pattern.</p> <p>Use <code>withHandler()</code> to set the request handler.</p> <p>Note</p> <p>You can route the same api to multiple patterns <pre><code>withPattern(\"GET /\")\nwithPattern(\"GET /api/greeting\")\nwithHandler(handler)\n</code></pre></p>"},{"location":"api/#echo","title":"Echo","text":"<p>You can send out text with <code>f.SendEcho()</code></p> <pre><code>func handler(req*f.Request, res *f.Response) {\n    f.SendEcho(res, \"hello\")\n}\n</code></pre>"},{"location":"api/#path","title":"Path","text":"<p>You can define path fields in your pattern using the curly braces format <code>{}</code>.</p> <pre><code>withPattern(\"GET /{name}\")\n</code></pre> <p>You can then retrieve the value of the path field with <code>f.ReceivePath()</code></p> <pre><code>func handler(req *f.Request, _ *f.Response) {\n    name := f.ReceivePath(req, \"name\")\n    f.SendEcho(res, \"hello \"+name)\n}\n</code></pre>"},{"location":"api/#status","title":"Status","text":"<p>You can send out a status code with <code>f.SendStatus()</code></p> <pre><code>func handler(_ *f.Request, res *f.Response) {\n    f.SendStatus(res, 404)\n    f.SendEcho(res, \"Resource not found, sorry.\")\n}\n</code></pre> <p>Note</p> <p>Status codes must be sent out before sending any header fields.</p>"},{"location":"api/#header","title":"Header","text":"<p>You can retrieve header fields with <code>f.ReceiveHeader()</code> and send out header fields with <code>f.SendHeader()</code>.</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    contentType := f.ReceiveHeader(req, \"Content-Type\")\n    if \"application/xml\" != contentType {\n        f.SendStatus(res, 400)\n        f.SendHeader(res, \"Content-Length\", \"69\")\n        f.SendEcho(res, \"We don't serve your kind around here, better get an XML encoder, heh.\")\n        return\n    }\n\n    f.SendStatus(res, 404)\n    f.SendHeader(res, \"Content-Length\", \"26\")\n    f.SendEcho(res, \"Resource not found, sorry.\")\n}\n</code></pre> <p>Note</p> <p>Header fields must be sent out before sending a body.</p>"},{"location":"api/#query","title":"Query","text":"<p>You can retrieve values of query fields with <code>f.ReceiveQuery()</code></p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    name := f.ReceiveQuery(req, \"name\")\n    f.SendEcho(res, \"hello \"+name)\n}\n</code></pre>"},{"location":"api/#forms","title":"Forms","text":"<p>Forms can be retrieved with <code>f.ReceiveForm()</code>.</p> <p>You can use the <code>url.Values</code> api in order to retrieve specific form fields.</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    form := f.ReceiveForm(req)\n    name := form.Get(\"name\")\n    f.SendEcho(res, \"hello \"+name)\n}\n</code></pre> <p>Note</p> <p>Forms must be passed through the body of the request, so verbs without body, like <code>GET</code> and <code>DELETE</code>, will fail to read the form.</p>"},{"location":"api/#json","title":"Json","text":"<p>Json bodies can be read and decoded with <code>f.ReceiveJson[T]()</code>.</p> <pre><code>type Person struct {\n    Name string\n}\n\nfunc handler(req *f.Request, res *f.Response) {\n    person, _ := f.ReceiveJson[Person](req)\n    f.SendEcho(res, \"hello \"+person.name)\n}\n</code></pre>"},{"location":"cancellation/","title":"Cancellation","text":"<p>Always track cancelled requests while streaming events, web sockets or executing long running tasks.</p> <p>You can detect cancelled requests with <code>f.ReceiveCancellation()</code>.</p> <pre><code>func RequestIsAlive(req *f.Request) *bool {\n    value := true\n    go func() {\n        &lt;-f.ReceiveCancellation(req)\n        value = false\n    }()\n    return &amp;value\n}\n</code></pre> <p>For example using sse</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    alive := RequestIsAlive(req)\n    setEventName := f.SendSseUpgrade(res)\n    setEventName(\"server-time\")\n\n    for *alive {\n        f.SendEcho(res, fmt.Sprintf(\"Server time is %s\", time.Now()))\n    }\n}\n</code></pre> <p>or using web sockets</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    alive := RequestIsAlive(req)\n    f.SendWsUpgrade(res)\n\n    for *alive {\n        f.SendEcho(res, \"hello\")\n        msg := f.ReceiveMessage(req)\n        fmt.Printf(\"Received message `%s`.\\n\", msg)\n    }\n}\n</code></pre>"},{"location":"certificates/","title":"Certificates","text":"<p>You can assign a certificate and a key for said certificate with <code>f.ServerWithCertificateAndKey()</code>.</p> <pre><code>f.ServerWithCertificateAndKey(srv, \"cert.pem\", \"key.pem\")\n</code></pre> <p>Note</p> <p>You can create a self-signed certificate for local development with <code>make certificate</code>, or interactively fill in the details of your certificate with <code>make certificate-interactive</code>.</p>"},{"location":"guards/","title":"Guards","text":"<p>Use <code>f.ServerWithGuard()</code> to add a new guard.</p> <p>Note</p> <p>A guard is a setup function that can inject arbitrary request handlers to handle incoming requests before they reach any of your api and page handlers. Guards can decide which requests should pass through and which request should be rejected.</p> <pre><code>f.ServerWithGuard(srv, guard)\n</code></pre> <p>Where <code>guard</code> is a setup function</p> <pre><code>func Guard(\n    withGuardHandler func(\n        guardHandler func(\n            req *f.Request,\n            res *f.Response,\n            pass func(),\n        ),\n    ),\n) {\n    withGuardHandler(guardHandler)\n}\n\nfunc guardHandler(req *f.Request, res *f.Response, pass func()) {\n    // Guard.\n    pass()\n}\n</code></pre> <p>Use <code>pass()</code> to let the current request pass through.</p> <p>Warning</p> <p>Failing to invoke <code>pass()</code> means the current request will be rejected.</p>"},{"location":"overview/","title":"Overview","text":"<p>Note</p> <p>This project is aimed mainly at linux distributions.</p> <p>Frizzante is a procedural, minimalistic and opinionated web server that uses Svelte to render web pages.</p> <p>Web pages can be rendered in one of 3 modes</p> <ul> <li>Server mode     Pages are rendered only on the server, resulting in a fully rendered html document from the server.</li> <li>Client mode     Pages are rendered only on the client, which means the client receives a basic html document which then renders the document by loading a JavaScript application asynchronously.</li> <li>Full mode     A combination of both \"Server mode\" and \"Client mode\".</li> </ul> <p>Each mode has its advantages and disadvantages.</p>"},{"location":"overview/#server-mode","title":"Server mode","text":"<p>In this mode no actual JavaScript is executed on the client's browser, you will have to deal away with <code>fetch</code> or any similar apis.</p> <p>Your new best friend is instead <code>&lt;form&gt;</code>.</p> <p>Your application will be a traditional web site, loading documents from scratch with almost every interaction,  making it easier to reason about state changes.</p> <p>On top of that, search engines will have an easy time rendering your document, and thus indexing it correctly.</p> <p>Most of the interactivity will have to come through either forms or Css.</p> <p>That being said, I say <code>most</code> because you can still inject external  JavaScript files through svelte's special <code>&lt;svelte:head&gt;</code> tag.</p> <pre><code>&lt;svelte:head&gt;\n    &lt;script type=\"text/javascript\" src=\"/some.js\" /&gt;\n    &lt;script type=\"text/javascript\" src=\"/some-other.js\" /&gt;\n&lt;/svelte:head&gt;\n</code></pre>"},{"location":"overview/#client-mode","title":"Client mode","text":"<p>In this mode you can build SPAs.</p> <p>Your server will serve a shell html template, which in turn will asynchronously load your JavaScript bundle and render your client application.</p>"},{"location":"overview/#full-mode","title":"Full mode","text":"<p>It's just as it sounds, in this mode the the server both fully renders an html document and also serves a JavaScript bundle, which once loaded, takes over the Dom.</p> <p>Although more powerful and versatile, this mode adds some complexity to your application.</p>"},{"location":"pages/","title":"Pages","text":"<p>Pages are just svelte components located in the <code>lib/pages</code> directory.</p> <p>You can refer to these pages by their relative file names.</p> <p>Example</p> <p>A page located at <code>lib/pages/welcome.svelte</code> will be identified by <code>welcome</code>.</p> <p>Subdirectories are joined by <code>.</code> instead of <code>/</code> or <code>\\</code>.</p> <p>Example</p> <p>A page located at <code>lib/pages/about/welcome.svelte</code> will be identified by <code>about.welcome</code>.</p>"},{"location":"pages/#index","title":"Index","text":"<p>An index is a function that routes one or more paths to a page.</p> <p>Use  <code>f.ServerWithIndex()</code> to create an index.</p> <pre><code>f.ServerWithIndex(srv, index)\n</code></pre> <p>Where <code>index</code> is a setup function.</p> <pre><code>func index(\n    withPage func(page string),\n    withPath func(path string),\n    withBaseHandler func(baseHandler func(req *f.Request, res *f.Response, page *f.Page)),\n    withActionHandler func(actionFunction func(req *f.Request, res *f.Response, page *f.Page)),\n){\n    withPage(\"welcome\")\n    withPath(\"/welcome\")\n    withBaseHandler(baseHandler)\n    withActionHandler(actionHandler)    \n}\n\nfunc baseHandler(req *f.Request, res *f.Response, page *f.Page) {\n    f.PageWithData(p, \"name\", \"Cat\")\n}\n\nfunc actionHandler(req *f.Request, res *f.Response, page *f.Page) {\n    modifyState()\n}\n</code></pre> <p>Use <code>withPage()</code> to specify which page should render.</p> <p>Use <code>withPath()</code> to specify which path to route.</p> <p>Note</p> <p>You can route multiple paths to the same page. <pre><code>withPage(\"welcome\")\nwithPath(\"/\")\nwithPath(\"/api/greeting\")\n</code></pre></p> <p>Warning</p> <p>You cannot route one path to multiple pages. <pre><code>withPage(\"welcome\")\nwithPage(\"login\") // This is now allowed.\nwithPath(\"/\")\n</code></pre></p> <p>Use <code>withBaseHandler()</code> to set the base page handler.</p> <p>Note</p> <p>A base page handler is a function that  handles requests to the <code>GET</code> http verb. This function usually does not modify the state,  it just renders information to the screen.</p> <p>Use <code>withActionHandler()</code> to set the action page handler.</p> <p>Note</p> <p>An action page handler is a function that  handles requests to the <code>POST</code> http verb. This function usually modifies the state and  sometimes redirects to some other page.</p> <p>Use <code>f.PageWithData()</code> to set data fields for the page.</p> <p>Note</p> <p>Data fields can be retrieved from your svelte components with getContext(\"data\").</p> <pre><code>&lt;script&gt;\n    import { getContext } from \"svelte\";\n    const data = getContext(\"data\")\n&lt;/script&gt;\n\n&lt;h1&gt;Hello {data.name}&lt;/h1&gt;\n</code></pre> <p>Note</p> <p>Context <code>data</code> is created with $state(), hence it is reactive.</p>"},{"location":"server-sent-events/","title":"Server sent events","text":"<p>You can upgrade http requests to server sent events with <code>f.SendSseUpgrade()</code>.</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    setEventName := f.SendSseUpgrade(res)\n    setEventName(\"server-time\")\n\n    for {\n        f.SendEcho(res, fmt.Sprintf(\"Server time is %s\", time.Now()))\n    }\n}\n</code></pre> <p>Set the name of the current event with <code>setEventName</code>,  then start sending content to the client with the usual <code>f.SendEcho()</code> and <code>f.SendJson()</code>.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the event stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming events. Read more about cancellation here.</p> <p>Note</p> <p>The default event name is <code>message</code>.</p> <p>Note</p> <p>Read more about <code>serve()</code> here.</p>"},{"location":"server/","title":"Server","text":"<p>You can create a server with <code>f.ServerCreate()</code> and start it with <code>f.ServerStart()</code>.</p> <pre><code>package main\n\nimport f \"github.com/razshare/frizzante\"\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerStart(srv)\n}\n</code></pre> <p>You'll need to create an embedded file system with <code>go:embed</code>, including the <code>.dist/*/**</code> pattern and pass  said embedded file system to the server.</p> <p>This will make it so that your svelte assets get embedded directly into the final executable.</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerWithEmbeddedFileSystem(srv, dist)\n    f.ServerStart(srv)\n}\n</code></pre> <p>By default, your server will be listening for requests at http://127.0.0.1:8080.</p> <p>You can customize both your host name and port number with <code>f.ServerWithHostname()</code> and <code>f.ServerWithPortNumber()</code>.</p> <pre><code>package main\n\nimport (\n    \"embed\"\n    f \"github.com/razshare/frizzante\"\n)\n\n//go:embed .dist/*/**\nvar dist embed.FS\n\nfunc main() {\n    srv := f.ServerCreate()\n    f.ServerWithPort(srv, 8989)\n    f.ServerWithHostName(srv, \"192.168.0.123\")\n    f.ServerWithEmbeddedFileSystem(srv, dist)\n    f.ServerStart(srv)\n}\n</code></pre>"},{"location":"sessions/","title":"Sessions","text":"<p>Use <code>f.SessionStart()</code> to start a session.</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    get, set, unset := f.SessionStart(req, res)\n}\n</code></pre> <p><code>f.SessionStart()</code> always succeeds and it always returns three functions, get, set and unset.</p> <p>Note</p> <p>The reason <code>f.SessionStart()</code> always succeeds is because it will automatically create a new session if none is found. The new session does not retain any data from the previous session.</p>"},{"location":"sessions/#get","title":"Get","text":"<p>Use <code>get()</code> to retrieve a session property.</p> <pre><code>get, _, _ := f.SessionStart(req, res)\nusername := get(\"username\", \"default\").(string)\n</code></pre>"},{"location":"sessions/#set","title":"Set","text":"<p>Use <code>set()</code> to create or update a session property.</p> <pre><code>_, set, _ := f.SessionStart(req, res)\nset(\"username\", \"frizzante\")\n</code></pre>"},{"location":"sessions/#unset","title":"Unset","text":"<p>Use <code>unset()</code> to remove a session property.</p> <pre><code>_, _, unset := f.SessionStart(req, res)\nunset(\"username\")\n</code></pre>"},{"location":"sessions/#session-operator","title":"Session operator","text":"<p>You can overwrite the default in-memory session operator and provide  your own <code>get</code>, <code>set</code>, <code>unset</code>, <code>validate</code> and <code>destroy</code> functions.</p> <p>Use <code>f.ServerWithSessionOperator()</code> to overwrite the default session operator</p> <pre><code>f.ServerWithSessionOperator(srv, func(\n    sessionId string,\n    withGetter func(get SessionGetter),\n    withSetter func(set SessionSetter),\n    withUnsetter func(unset SessionUnsetter),\n    withValidator func(validate SessionValidator),\n    withDestroyer func(destroy SessionDestroyer),\n) {\n    withGetter(func(key string, defaultValue any) (value any) {\n        // Get `key` from the session store.\n        // If `key` doesn't exist, create it with value `defaultValue`.\n    })\n\n    withSetter(func(key string, value any) {\n        // Set `key` to the session store.\n    })\n\n    withUnsetter(func(key string) {\n        // Unset `key` from the session store.\n    })\n\n    withValidator(func() (valid bool) {\n        // Validate `sessionId`.\n    })\n\n    withDestroyer(func() {\n        // Destroy the session `sessionId` and its store.\n    })\n})\n</code></pre> <p>Note</p> <p>The <code>withValidator()</code> function is used by Frizzante to validate sessions whenever you invoke <code>f.SessionStart()</code>.  The <code>withDestroyer()</code> function is used by Frizzante to destroy a sessions whenever validation fails.</p>"},{"location":"sessions/#lifetime","title":"Lifetime","text":"<p>The <code>f.SessionStart()</code> function does not set any expiration date, domain or path on the session cookie sent to the browser.</p> <p>Instead, <code>f.ServerWithSessionOperator()</code> has complete control over the lifetime of any session.</p>"},{"location":"web-sockets/","title":"Web sockets","text":"<p>You can upgrade http requests to web sockets with <code>f.SendWsUpgrade()</code>.</p> <pre><code>func handler(req *f.Request, res *f.Response) {\n    f.SendWsUpgrade(res)\n\n    for {\n        f.SendEcho(res, \"hello\")\n        msg := f.ReceiveMessage(req)\n        fmt.Printf(\"Received message `%s`.\\n\", msg)\n    }\n}\n</code></pre> <p>Use the usual <code>f.SendEcho()</code> to send a raw text message and <code>f.SendJson()</code> to send a json message to the client.</p> <p>Once the request handler returns,  for example by exiting the <code>for</code> loop,  the web socket stream ends.</p> <p>Warning</p> <p>Always track cancelled requests while streaming web sockets. Read more about cancellation here.</p> <p>Note</p> <p>Read more about <code>serve()</code> here.</p>"}]}